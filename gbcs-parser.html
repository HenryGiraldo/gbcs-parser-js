<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="GBCS Message Parser">
<!--
  gbcs-parser.html - GBCS message parser

  Copyright (C) 2019 Andre B. Oliveira
                2019 Enrique Giraldo

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see https://www.gnu.org/licenses/.
-->
<title>GBCS Message Parser</title>
<style>
body { background-color: #fff; color: #000; font-family: Consolas, monaco, monospace; font-size: small; }
h1 { color: #009ee2; }
a.plain { text-decoration: none; color: inherit; }
a.plain:visited { color: inherit; }
textarea { width: 100%; resize: vertical; box-sizing: border-box; font-family: Consolas, monaco, monospace; font-size: small; }
table { border-collapse: collapse; table-layout: fixed; width: 100%; }
tr:nth-child(odd) { background-color: #f0f8ff; }
th { border: 1px solid #009ee2; background-color: #009ee2; color: #fff; font-weight: bold; }
th.attribute { background-color: #60b8dd; }
td { border: 1px solid #009ee2; padding: 1px 2px; vertical-align: top; white-space: pre-wrap; }
th.gbt { background-color: #10a57e; border: 1px solid #10a57e; }
th.empty { background-color: #ffffff; border-left: none; border-right: none; }
th.sensitive { background-color: #b072d6; border-color: #b072d6; }
th.sensitive.attribute { background-color: #c69fdf; }
tr.sensitive { background-color: #f0e0ff; }
tr.sensitive:nth-child(even) { background-color: #fbf2ff; }
tr.sensitive>td { border-color: #b072d6; }
div.tooltip { display: inline; cursor: help; }
</style>
</head>
<body>
<h1><a class="plain" href="gbcs-parser.html">GBCS Message Parser</a></h1>
<p><textarea id="textarea" rows="7" placeholder="Paste here the hex string of the GBCS message" autofocus></textarea>
<p><button type="button" onclick="parse()">Parse</button>
<p><table id="table"></table>
<p>GBCS V3.1 Use Cases: <a href="gbcs-use-cases.html">gbcs-use-cases.html</a>
<p>DLMS V3.1 Use Cases: <a href="dlms-use-cases.html">dlms-use-cases.html</a>
<p>Service Request to Use Cases: <a href="service-request-use-cases.htm">service-request-use-cases.htm</a>
<p>Source: <a href="https://github.com/HenryGiraldo/gbcs-parser-js">https://github.com/HenryGiraldo/gbcs-parser-js</a>
<hr>
<p>This parser is maintained thanks to the support of <a href="https://woodswallow.tech/">WoodSwallow</a> and <a href="https://www.edmi-meters.com/europe/">EDMI</a>.</p>
<script>

monthsInYear = {1: "January", 2: "February", 3: "March", 4: "April", 5: "May", 6: "June",
                7: "July", 8: "August", 9: "September", 10: "October", 11: "November", 12: "December"};
daysInWeek = {1: 'Monday', 2: 'Tuesday', 3: 'Wednesday', 4: 'Thursday',
              5: 'Friday', 6: 'Saturday', 7: 'Sunday', 0xFF: 'day'};

function parse() {
    var table = document.getElementById("table");
    table.innerHTML = parseGbcsMessage(textarea.value);
    hash = '#' + textarea.value.replace(/\s/g, '');
    if (hash.length < 2000) {
      try {
        window.location.hash = hash;
      } catch (e) {
        window.location.hash = hash = '#';
      }
    } // fails with longer than 2025 to 2050 chars in IE/Edge
}

function str2u8array(str) {
      const buf = new Uint8Array(str.length);
      for (var i = 0, strLen = str.length; i < strLen; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    }

function escapeHtml(unsafe) {
  return String(unsafe)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function tooltip(text, tip) {
  return '<div class="tooltip" title="' + tip + '">' + text + '</div>';
}

function toHex(number, bits) {
  return "0x" + (number + Math.pow(2, bits)).toString(16).toUpperCase().substr(-bits / 4);
}

function parseGbcsMessage(text) {
  var output = "";
  var sensitive = false;

  var x = parseHexString(text);
  if (x.input[0] != 0xDD && x.input[0] != 0xDF) {
    // input could be base64 encoded
    var y = parseBase64String(text);
    if (y.input[0] == 0xDD || y.input[0] == 0xDF) {
      // assume base64 encoding if it starts with a known tag
      x = y;
    }
  }
  if (x.input[0] == 0xDD) {
    if (x.input[1] == 0x00) {
      parseGeneralCiphering(x);
    } else {
      var gbt = [];
      do {
        var block = parseGeneralBlockTransfer(x);
        if (block.number > 255 || block.lengt > 1200) {
          // something is wrong, fail
          putUnparsedBytes(x);
          break;
        }
        if (x.end - x.index > 0) {
          putSeparator("<br>", "empty");
        }
        if (block.number > 0 && block.len > 0) {
          gbt[block.number - 1] = block;
        }
      } while (x.index < x.end);
      processGeneralBlockTransfer(gbt);
    }
  } else {
    parseGeneralSigning(x);
  }
  return output;

  function putSeparator(title, klass) {
    if (sensitive) {
      klass = klass && klass + " sensitive" || "sensitive";
    }
    if (!klass) {
      output += '<tr><th colspan="3">' + title;
    } else {
      output += '<tr><th class="' + klass + '" colspan="3">' + title;
    }
  }

  function putBytes(name, bytes, notes) {
    if (sensitive)
      output += "<tr class=\"sensitive\"><td>" + name + "<td>";
    else
      output += "<tr><td>" + name + "<td>";
    var h = "0123456789ABCDEF";
    var n = bytes.end - bytes.index;
    for (var i = 0; i < n; i++) {
      if (i > 0) {
        output += " ";
      }
      var b = bytes.input[bytes.index++];
      output += h.charAt((b >> 4) & 15) + h.charAt(b & 15);
    }
    output += "<td>"
    if (notes != undefined) {
      output += notes;
    }
  }

  function putUnparsedBytes(bytes) {
    if (bytes.end - bytes.index > 0) {
      putBytes("Unknown", bytes, "ERROR: Unexpected data");
    }
  }

  function parseHexString(text) {
    var bytes = new Uint8Array(text.length / 2);
    var length = 0;
    for (var i = 0; i + 1 < text.length; i++) {
      var c = text.charCodeAt(i);
      if ((c > 47 && c < 58) || (c > 64 && c < 71) || (c > 96 && c < 103)) {
        c = text.charCodeAt(i + 1);
        if ((c > 47 && c < 58) || (c > 64 && c < 71) || (c > 96 && c < 103)) {
          bytes[length++] = parseInt(text.substr(i++, 2), 16);
        }
      }
    }
    return { input: bytes, index: 0, end: length };
  }

  function parseBase64String(text) {
    var bytes = str2u8array(window.atob(text));
    return { input: bytes, index: 0, end: bytes.length };
  }

  function getBytes(x, n) {
    var y = { input: x.input, index: x.index, end: x.index + n };
    x.index += n;
    return y;
  }

  function peekBytes(x, n) {
    var y = { input: x.input, index: x.index, end: x.index + n };
    return y;
  }

  function getLink(name, loc, klass) {
    if (klass) {
      return "<a class=\"" + klass + "\" href=\"" + loc + "\" target=\"_blank\">" + name + " ðŸ¡•</a>";
    }
    return "<a href=\"" + loc + "\" target=\"_blank\">" + name + " ðŸ¡•</a>";
  }

  function parseGeneralCiphering(x) {
    putSeparator("MAC Header");
    putBytes("General Ciphering", getBytes(x, 7));
    var len = parseEncodedLength(x, "Ciphered Service Length");
    var y = getBytes(x, len);
    putBytes("Security Header", getBytes(y, 5));
    parseGeneralSigning(getBytes(y, len - 5 - 12));
    putSeparator("MAC");
    putBytes("MAC", getBytes(y, 12));
  }

  function parseGeneralBlockTransfer(x) {
    putSeparator("Message Routing Header");
    putBytes("General Ciphering", getBytes(x, 2));
    parseCraFlag(x);
    parseCounter("Originator Counter", x);
    putBytes("Originator System Title", getBytes(x, 9));
    putBytes("Recipient System Title", getBytes(x, 9));
    putBytes("Date Time", getBytes(x, 1));
    putBytes("Other Info Length", getBytes(x, 1));
    parseMessageCode(" Message Code", x);
    putBytes("Key Info", getBytes(x, 1));
    parseEncodedLength(x, "Ciphered Service Length");
    putBytes("Security Header", getBytes(x, 5));
    putSeparator("GBT Header");
    putBytes("General Block Transfer", getBytes(x, 1));
    var blockControl = x.input[x.index];
    var lastBlock = (blockControl >> 7) & 1;
    var streaming = (blockControl >> 6) & 1;
    var window = blockControl & 0x3f;
    putBytes("Block Control", getBytes(x, 1), "Last Block: " + lastBlock + ", Streaming: " + streaming + ", Window: " + window);
    var blockNumber = parseNumber(x, 2);
    putBytes("Block Number", getBytes(x, 2), blockNumber);
    var blockNumberAck = parseNumber(x, 2);
    putBytes("Block Number Ack", getBytes(x, 2), blockNumberAck);
    var blockDataLen = parseEncodedLength(x, "Block Data Length");
    var blockData = peekBytes(x, blockDataLen);
    putBytes("Block Data", getBytes(x, blockDataLen));
    return { last: lastBlock, streaming: streaming, window: window, number: blockNumber, ack: blockNumberAck, data: blockData, len: blockDataLen };
  }

  function processGeneralBlockTransfer(gbt) {
    // find last block
    var last = -1;
    for (var i = 0; i < gbt.length; i++) {
      if (gbt[i] && gbt[i].last != 0) {
        last = i;
      }
    }
    // check if all blocks present
    var allBlocks = true;
    for (var i = 0; i <= last; i++) {
      if (gbt[i] == undefined) {
        allBlocks = false;
        break;
      }
    }
    if (last > 0 && allBlocks) {
      var full = "";
      for (var index = 0; index < gbt.length; index++) {
        var block = gbt[index];
        var h = "0123456789ABCDEF";
        for (var i = block.data.index; i < block.data.end; i++) {
          var b = block.data.input[i];
          full += h.charAt((b >> 4) & 15) + h.charAt(b & 15);
        }
        if (block.last != 0) {
          break;
        }
      }
      putSeparator("<br>", "empty");
      putSeparator(getLink("GBT Reconstructed Data", "#" + full, "plain"), "gbt");
      output += parseGbcsMessage(full);
    }
  }

  function parseGeneralSigning(x) {
    putSeparator("Grouping Header");
    var signedDataStart = x.index + 1;
    putBytes("General Signing", getBytes(x, 2));
    var craFlag = parseCraFlag(x);
    cipherInfo = {};
    cipherInfo.origCounter = x.input.subarray(x.index, x.index + 8);
    parseCounter("Originator Counter", x);
    cipherInfo.origSysTitle = x.input.subarray(x.index + 1, x.index + 9);
    putBytes("Originator System Title", getBytes(x, 9));
    cipherInfo.recipSysTitle = x.input.subarray(x.index + 1, x.index + 9);
    putBytes("Recipient System Title", getBytes(x, 9));
    parseDlmsOctetString(x, "Date Time", false);
    var otherInfoLen = parseEncodedLength(x, "Other Information Length");
    var otherInfo = getBytes(x, otherInfoLen);
    var messageCode = parseMessageCode(" Message Code", otherInfo);
    if (otherInfoLen >= 10) {
      putBytes(" Supplementary Remote Party ID", getBytes(otherInfo, 8));
      if (otherInfoLen >= 18) {
        parseCounter(" Supplementary Remote Party Counter", otherInfo);
        if (otherInfoLen == 26) {
          parseCounter(" Supplementary Originator Counter", otherInfo);
        } else if (otherInfoLen > 26) {
          parseCertificate(otherInfo, " Supplementary Remote Party Key Agreement Certificate");
        }
      }
    }
    var contentLen = parseEncodedLength(x, "Content Length");
    parsePayload(getBytes(x, contentLen), messageCode, craFlag);
    var signedDataEnd = x.index;
    putSeparator("Signature");
    var signatureLen = parseEncodedLength(x, "Signature Length");
    if (signatureLen > 0) {
      var s = getBytes(x, signatureLen);
      var dataToSign = x.input.subarray(signedDataStart, signedDataEnd);
      var signature = s.input.subarray(s.index, s.end);
      putBytes("Signature", s, '<div id="signature-check"></div>');

      execIfSignatureCheckIsAvailable(function() {
        // When this is executed message has been processed and DOM updated
        var signatureCheck = document.getElementById("signature-check");
        if (signatureCheck) {
          var pubkey = document.createElement("textarea");
          pubkey.id = "pub-key";
          pubkey.rows = "6";
          pubkey.placeholder =
            "Paste here the digital signature certificate or public key in PEM format for "
            + arrayToHex(cipherInfo.origSysTitle).toUpperCase() + ".";
          var button = document.createElement("button");
          button.innerText = "Verify";
          button.onclick = function() {
            checkSignature(dataToSign, signature);
          };
          var verifStatus = document.createElement("div");
          verifStatus.id = "verif-status";
          verifStatus.innerHTML = "<p> </p>";
          signatureCheck.appendChild(pubkey);
          signatureCheck.appendChild(button);
          signatureCheck.appendChild(verifStatus);
        }
      });
    }
  }

  // Execute callback asynchronously if WebCrypto ECDSA with P-256 curve is available.
  function execIfSignatureCheckIsAvailable(callback) {
    try {
      window.crypto.subtle.importKey(
        "jwk",
        {
          "kty": "EC",
          "crv": "P-256",
          "x": "f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU",
          "y": "x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0"
        },
        { name: 'ECDSA', namedCurve: 'P-256' },
        false,
        [ "verify" ]
      )
      .then(callback);
    } catch (e) { }
  }

  function checkSignature(dataToSign, signature) {

    function updateStatus(result, error) {
      var verifStatus = document.getElementById("verif-status");
      if (result) {
        verifStatus.innerHTML = '<p style="color: green">Verification <b>PASSED</b></p>';
      } else {
        if (error) {
          verifStatus.innerHTML = '<p style="color: red">' + error + '</p>';
        } else {
          verifStatus.innerHTML = '<p style="color: red">Verification <b>FAILED</b></p>';
        }
      }
    }

    function publicKeyFromPem(pem) {
      const pemHeader = "-----BEGIN PUBLIC KEY-----";
      const pemFooter = "-----END PUBLIC KEY-----";
      var pemContents = pem;
      if (pem.startsWith(pemHeader) && pem.endsWith(pemFooter)) {
        pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);
      }
      // Try parsing the public key even if it does not have header/footer
      try {
        // TODO: import hex encoded keys
        const binaryDerString = window.atob(pemContents);
        const binaryDer = str2u8array(binaryDerString);
        return binaryDer;
      } catch (e) {
        return null;
      }
    }

    function publicKeyFromCert(pem) {
      const pemHeader = "-----BEGIN CERTIFICATE-----";
      const pemFooter = "-----END CERTIFICATE-----";
      var pemContents = pem;
      if (pem.startsWith(pemHeader) && pem.endsWith(pemFooter)) {
        pemContents = pem.substring(pemHeader.length, pem.length - pemFooter.length);
      }
      // Try parsing the certificate even if it does not have header/footer
      const binaryDerString = window.atob(pemContents);
      const binaryDer = str2u8array(binaryDerString);
      const certificate = parsePemCertificate(binaryDer);

      const alg = certificate.tbsCertificate.signature.algorithm;
      const publicKeyType = certificate.tbsCertificate.subjectPublicKeyInfo.algorithm.algorithm;
      const namedCurve = certificate.tbsCertificate.subjectPublicKeyInfo.algorithm.parameters.curve;
      if (alg !== "1.2.840.10045.4.3.2" &&          // ecdsaWithSHA256
        publicKeyType !== "1.2.840.10045.2.1" &&    // ecPublicKey
        namedCurve !== "1.2.840.10045.3.1.7") {     // prime256v1
        throw new Error("Signature algorithm " + alg + " is not supported.");
      }
      return certificate.tbsCertificate.subjectPublicKeyInfo.asn1.raw;
    }

    var pubkey = document.getElementById("pub-key");
    document.getElementById("verif-status").innerHTML = "<p>âŒ›</p>";

    try {
      const pem = pubkey.value.trim();
      var derKey;
      derKey = publicKeyFromPem(pem);

      window.crypto.subtle.importKey(
        "spki",   // TODO: "raw" (omit algorithm identifier)
        derKey,
        { name: "ECDSA", namedCurve: "P-256" },
        true,
        [ "verify" ]
      )
      .catch(function(e) {
        // It is not a public key, maybe it is a certificate
        derKey = publicKeyFromCert(pem);
        return window.crypto.subtle.importKey(
          "spki",
          derKey,
          { name: "ECDSA", namedCurve: "P-256" },
          true,
          [ "verify" ]
        );
      })
      .then(function (key) {
        return window.crypto.subtle.verify(
          { name: "ECDSA", hash: "SHA-256" },
          key,
          signature,
          dataToSign
        );
      })
      .then(function (result) {
        if (result) {
          updateStatus(true);
        } else {
          updateStatus(false);
        }
      })
      .catch(function (e) {
        updateStatus(false, e);
      });
    } catch (e) {
      updateStatus(false, e);
    }
  }


  // From https://blog.engelke.com/2014/10/21/web-crypto-and-x-509-certificates/
  function parsePemCertificate(byteArray) {
    var asn1 = berToJavaScript(byteArray);
    if (asn1.cls !== 0 || asn1.tag !== 16 || !asn1.structured) {
      throw new Error("This can't be an X.509 certificate. Wrong data type.");
    }

    var cert = {asn1: asn1};  // Include the raw parser result for debugging
    var pieces = berListToJavaScript(asn1.contents);
    if (pieces.length !== 3) {
      throw new Error("Certificate contains more than the three specified children.");
    }

    cert.tbsCertificate     = parseTBSCertificate(pieces[0]);
    cert.signatureAlgorithm = parseAlgorithmIdentifier(pieces[1]);
    cert.signatureValue     = parseSignatureValue(pieces[2]);

    return cert;

    function berListToJavaScript(byteArray) {
      var result = new Array();
      var nextPosition = 0;
      while (nextPosition < byteArray.length) {
        var nextPiece = berToJavaScript(byteArray.subarray(nextPosition));
        result.push(nextPiece);
        nextPosition += nextPiece.byteLength;
      }
      return result;
    }

    function parseSignatureValue(asn1) {
      if (asn1.cls !== 0 || asn1.tag !== 3 || asn1.structured) {
        throw new Error("Bad signature value. Not a BIT STRING.");
      }
      var sig = {asn1: asn1};   // Useful for debugging
      sig.bits = berBitStringValue(asn1.contents);
      return sig;
    }

    function berBitStringValue(byteArray) {
      return {
        unusedBits: byteArray[0],
        bytes: byteArray.subarray(1)
      };
    }

    function parseAlgorithmIdentifier(asn1) {
      if (asn1.cls !== 0 || asn1.tag !== 16 || !asn1.structured) {
        throw new Error("Bad algorithm identifier. Not a SEQUENCE.");
      }
      var alg = {asn1: asn1};
      var pieces = berListToJavaScript(asn1.contents);
      if (pieces.length > 2) {
        throw new Error("Bad algorithm identifier. Contains too many child objects.");
      }
      var encodedAlgorithm = pieces[0];
      if (encodedAlgorithm.cls !== 0 || encodedAlgorithm.tag !== 6 || encodedAlgorithm.structured) {
        throw new Error("Bad algorithm identifier. Does not begin with an OBJECT IDENTIFIER.");
      }
      alg.algorithm = berObjectIdentifierValue(encodedAlgorithm.contents);
      if (pieces.length === 2) {
        var encodedCurve = pieces[1];
        if (encodedCurve.cls !== 0 || encodedCurve.tag !== 6 || encodedCurve.structured) {
          throw new Error("Bad algorithm identifier. Does not contain valid parameters.");
        }
        alg.parameters = {asn1: pieces[1]};
        alg.parameters.curve = berObjectIdentifierValue(encodedCurve.contents);
      } else {
        alg.parameters = null;  // It is optional
      }
      return alg;
    }

    function berObjectIdentifierValue(byteArray) {
      var oid = Math.floor(byteArray[0] / 40) + "." + byteArray[0] % 40;
      var position = 1;
      while(position < byteArray.length) {
        var nextInteger = 0;
        while (byteArray[position] >= 0x80) {
          nextInteger = nextInteger * 0x80 + (byteArray[position] & 0x7f);
          position += 1;
        }
        nextInteger = nextInteger * 0x80 + byteArray[position];
        position += 1;
        oid += "." + nextInteger;
      }
      return oid;
    }

    function parseTBSCertificate(asn1) {
      if (asn1.cls !== 0 || asn1.tag !== 16 || !asn1.structured) {
        throw new Error("This can't be a TBSCertificate. Wrong data type.");
      }
      var tbs = {asn1: asn1};  // Include the raw parser result for debugging
      var pieces = berListToJavaScript(asn1.contents);
      if (pieces.length < 7) {
        throw new Error("Bad TBS Certificate. There are fewer than the seven required children.");
      }
      tbs.version = pieces[0];
      tbs.serialNumber = pieces[1];
      tbs.signature = parseAlgorithmIdentifier(pieces[2]);
      tbs.issuer = pieces[3];
      tbs.validity = pieces[4];
      tbs.subject = pieces[5];
      tbs.subjectPublicKeyInfo = parseSubjectPublicKeyInfo(pieces[6]);
      return tbs;  // Ignore optional fields for now
    }

    function parseSubjectPublicKeyInfo(asn1) {
      if (asn1.cls !== 0 || asn1.tag !== 16 || !asn1.structured) {
        throw new Error("Bad SPKI. Not a SEQUENCE.");
      }
      var spki = {asn1: asn1};
      var pieces = berListToJavaScript(asn1.contents);
      if (pieces.length !== 2) {
        throw new Error("Bad SubjectPublicKeyInfo. Wrong number of child objects.");
      }
      spki.algorithm = parseAlgorithmIdentifier(pieces[0]);
      spki.bits = berBitStringValue(pieces[1].contents);
      return spki;
    }

    // From https://blog.engelke.com/2014/10/17/parsing-ber-and-der-encoded-asn-1-objects/
    function berToJavaScript(byteArray) {
      "use strict";
      var result = {};
      var position = 0;

      result.cls              = getClass();
      result.structured       = getStructured();
      result.tag              = getTag();
      var length              = getLength(); // As encoded, which may be special value 0

      if (length === 0x80) {
        length = 0;
        while (byteArray[position + length] !== 0 || byteArray[position + length + 1] !== 0) {
          length += 1;
        }
        result.byteLength   = position + length + 2;
        result.contents     = byteArray.subarray(position, position + length);
      } else {
        result.byteLength   = position + length;
        result.contents     = byteArray.subarray(position, result.byteLength);
      }

      result.raw              = byteArray.subarray(0, result.byteLength); // May not be the whole input array
      return result;

      function getClass() {
        var cls = (byteArray[position] & 0xc0) / 64;
        // Consumes no bytes
        return cls;
      }

      function getStructured() {
        var structured = ((byteArray[0] & 0x20) === 0x20);
        // Consumes no bytes
        return structured;
      }

      function getTag() {
        var tag = byteArray[0] & 0x1f;
        position += 1;
        if (tag === 0x1f) {
          tag = 0;
          while (byteArray[position] >= 0x80) {
            tag = tag * 128 + byteArray[position] - 0x80;
            position += 1;
          }
          tag = tag * 128 + byteArray[position] - 0x80;
          position += 1;
        }
        return tag;
      }

      function getLength() {
        var length = 0;

        if (byteArray[position] < 0x80) {
          length = byteArray[position];
          position += 1;
        } else {
          var numberOfDigits = byteArray[position] & 0x7f;
          position += 1;
          length = 0;
          for (var i=0; i<numberOfDigits; i++) {
            length = length * 256 + byteArray[position];
            position += 1;
          }
        }
        return length;
      }
    }
  }

  function parsePayload(x, messageCode, craFlag) {
    putSeparator("Payload");
    try {
      if (messageCode == 0x0008) {  // CS02a
        if (craFlag == 1) {
          parseProvideSecurityCredentialDetailsCommand(x);
        } else {
          parseProvideSecurityCredentialDetailsResponse(x);
        }
      } else if (messageCode >= 0x0100 && messageCode <= 0x0109) {  // CS02b
        if (craFlag == 1) {
          parseUpdateSecurityCredentialsCommand(x);
        } else {
          parseUpdateSecurityCredentialsResponse(x);
        }
      } else if (messageCode == 0x00CB) {  // CS02b alert
        parseUpdateSecurityCredentialsAlert(x);
      } else if (messageCode == 0x000A) {  // CS02c
        if (craFlag == 1) {
          parseIssueSecurityCredentialsCommand(x);
        } else {
          parseIssueSecurityCredentialsResponse(x);
        }
      } else if (messageCode == 0x000B) {  // CS02d
        if (craFlag == 1) {
          parseUpdateDeviceCertificateCommand(x);
        } else {
          parseUpdateDeviceCertificateResponse(x);
        }
      } else if (messageCode == 0x000C) {  // CS02e
        if (craFlag == 1) {
          parseProvideDeviceCertificateCommand(x);
        } else {
          parseProvideDeviceCertificateResponse(x);
        }
      } else if (messageCode == 0x000D || messageCode == 0x00AB || messageCode == 0x000E || messageCode == 0x00AF) {  // CS03A1 || CS03A2 || CS03B || CS03C
        if (craFlag == 1) {
          parseJoinDeviceCommand(x);
        } else {
          parseJoindDeviceResponse(x);
        }
      } else if (messageCode == 0x000F || messageCode == 0x0010) {  // CS04AC || CS04B
        if (craFlag == 1) {
          parseUnjoinDeviceCommand(x);
        } else {
          parseUnjoindDeviceResponse(x);
        }
      } else if (messageCode == 0x0012) {  // CS06
        if (craFlag == 1) {
          parseActivateFirmwareCommand(x);
        } else {
          parseActivateFirmwareResponse(x);
        }
      } else if (messageCode == 0x00CA) {  // CS06 alert
        parseActivateFirmwareAlert(x);
      } else if (messageCode == 0x0013) {  // CS07
        if (craFlag == 1) {
          parseReadDeviceJoinDetailsCommand(x);
        } else {
          parseReadDeviceJoinDetailsResponse(x);
        }
      } else if (messageCode == 0x007F) {  // GCS28
        if (craFlag == 1) {
          parseSetTimeCommand(x);
        } else {
          parseSetTimeResponse(x);
        }
      } else if (messageCode == 0x008B) {  // GCS53
        parseGbzGcs53AlertPayload(x);
      } else if (messageCode == 0x008C) {  // GCS59
        if (craFlag == 1) {
          parseGpfDeviceLogRestoreCommand(x);
        } else {
          parseGpfDeviceLogRestoreResponse(x);
        }
      } else if (messageCode == 0x00B2) {  // GCS62
        parseGpfDeviceLogBackupAlert(x);
      } else if (messageCode == 0x00CC) {  // Future Dated DLMS
        parseDlmsFutureDatedAlert(x);
      } else if (messageCode == 0x00CD) {  // Future Dated GBZ
        parseGbzFutureDatedAlertPayload(x);
      } else if (messageCode == 0x00CE) {  // FW Distribution Receipt Alert ESME
        parseDlmsFirmwareDistributionReceiptAlert(x);
      } else if (messageCode == 0x00CF) {  // FW Distribution Receipt Alert GSME
        parseGbzFirmwareDistributionReceiptAlert(x);
      } else if (messageCode == 0x0061) {  // ECS68
        parseDlmsBillingDataLogAlert(x);
      } else if (messageCode == 0x00D5) {  // 8F84 Alert
        parseFailureToDeliverRemotePartyToEsme(x);
      } else if (x.input[x.index] == 1 && x.input[x.index + 1] == 9) {
        if (craFlag == 3) {
          parseGbzAlertPayload(x);
        } else {
          parseGbzPayload(x);
        }
      } else if (x.input[x.index] == 0xD9) {
        parseDlmsAccessRequest(x);
      } else if (x.input[x.index] == 0xDA) {
        parseDlmsAccessResponse(x, messageCode);
      } else if (x.input[x.index] == 0x0F) {
        parseDlmsDataNotificationGbcsAlert(x);
      } else {
        putBytes("Payload", x);
      }
    } catch(error) {
      putBytes("ERROR", x, error);
    }
    putUnparsedBytes(x);
  }

  function parseEncodedLength(x, name) {
    var lenSz = parseLength(x, 0);
    putBytes(name, getBytes(x, lenSz.size), lenSz.length);
    return lenSz.length;
  }

  function parseCraFlag(x) {
    var craFlag = x.input[x.index];
    putBytes("CRA Flag", getBytes(x, 1), { 1: "Command", 2: "Response", 3: "Alert" }[craFlag] || "INVALID");
    return craFlag;
  }

  function parseCounter(name, x) {
    var bytes = getBytes(x, 8);
    putBytes(name, bytes, getDecimalString(bytes));
  }

  function getDecimalString(x) {
    var value64 = [ 0, 0 ];
    var fixedPoint = 1000000000000;
    for (var i = x.index; i < x.end; i++) {
      var lsb = value64[0] * 256 + x.input[i];
      var msb = value64[1] * 256 + Math.floor(lsb / fixedPoint);
      value64[0] = Math.floor(lsb % fixedPoint);
      value64[1] = msb;
    }
    var decimalString = "";
    do {
      decimalString = String.fromCharCode(Math.floor(value64[0] % 10) + 0x30) + decimalString;
      value64[0] = Math.floor(value64[0] / 10) + Math.floor(value64[1] % 10) * (fixedPoint / 10);
      value64[1] = Math.floor(value64[1] / 10);
    } while (value64[0] || value64[1]);
    return decimalString;
  }

  function parseMessageCode(name, x) {
    var usecases = {
      0x0001: "CCS01 Add Device to CHF device log",
      0x0002: "CCS02 Remove device from CHF device log",
      0x0003: "CCS03 Restore CHF Device Log",
      0x0007: "CS01a Apply Prepayment Top Up to an ESME",
      0x0008: "CS02a Provide Security Credentials Details",
      0x000A: "CS02c Issue Security Credentials",
      0x000B: "CS02d Update Device Certificates on Device",
      0x000C: "CS02e Provide Device Certificates from Device",
      0x000D: "CS03A1 Method A Join (Meter)",
      0x000E: "CS03B Method B Join",
      0x000F: "CS04AC Method A or C Unjoin",
      0x0010: "CS04B Method B Unjoin",
      0x0012: "CS06 Activate Firmware",
      0x0013: "CS07 Read Device Join Details",
      0x0014: "CS10a Read ZigBee Device Event Log",
      0x0015: "CS11 Clear ZigBee Device Event Log",
      0x0018: "CS14 Device Addition To / Removal From HAN Whitelist Alerts",
      0x0019: "ECS01a Set Tariff and Price on ESME",
      0x001A: "ECS02 Set ESME Payment Mode to Credit",
      0x001B: "ECS03 Set ESME Payment Mode to Prepayment",
      0x001C: "ECS04a Adjust Meter Balance on the ESME",
      0x001D: "ECS05 Reset Tariff Block Counter Matrix",
      0x001E: "ECS07 Manage Debt on the ESME",
      0x001F: "ECS08 Update Prepayment Configuration on ESME",
      0x0020: "ECS09 Activate Emergency Credit Remotely on ESME",
      0x0021: "ECS10 Send Message to ESME",
      0x0022: "ECS12 Set Change of Tenancy date on ESME",
      0x0023: "ECS14 Disable Privacy PIN Protection on ESME",
      0x0024: "ECS15a Clear ESME Event Log",
      0x0025: "ECS16 Write Supplier Contact Details on ESME",
      0x0026: "ECS17a Read ESME Energy Registers (Export Energy)",
      0x0027: "ECS17b Read ESME Energy Registers (Import Energy)",
      0x0028: "ECS17c Read ESME Energy Registers (Power)",
      0x0029: "ECS17d Read ESME Energy Register (TOU)",
      0x002A: "ECS17e Read ESME Energy Register (TOU with Blocks)",
      0x002B: "ECS18a Read Maximum Demand Registers (export)",
      0x002C: "ECS18b Read Maximum Demand Registers (import)",
      0x002D: "ECS19 Read ESME Prepayment Registers",
      0x002E: "ECS20a Read ESME Billing Data Log (payment based debt payments)",
      0x002F: "ECS20b Read ESME Billing Data Log (change of mode / tariff triggered exc export)",
      0x0030: "ECS20c Read ESME Billing Data Log (billing calendar triggered exc export)",
      0x0033: "ECS21a Read Electricity Daily Read Log (exc export)",
      0x0034: "ECS21b Read Electricity (Prepayment) Daily Read Log",
      0x0035: "ECS21c Read Electricity Daily Read Log (export only)",
      0x0036: "ECS22a Read Electricity Half Hour Profile Data (export)",
      0x0037: "ECS22b Read Electricity Half Hour Profile Data (active import)",
      0x0038: "ECS22c Read Electricity Half Hour Profile Data (reactive import)",
      0x0039: "ECS23 Read Voltage Operational Data",
      0x003A: "ECS24 Read ESME Tariff Data",
      0x003B: "ECS26a Read ESME Configuration Data Prepayment",
      0x003C: "ECS26b Read ESME Configuration Voltage Data",
      0x003D: "ECS26c Read ESME Configuration Data Device Information (randomisation)",
      0x003E: "ECS26d Read ESME Configuration Data Device Information (Billing Calendar)",
      0x003F: "ECS26e Read ESME Configuration Data Device Information (device identity exc MPAN)",
      0x0040: "ECS26f Read ESME Configuration Data Device Information (instantaneous power thresholds)",
      0x0042: "ECS27 Read ESME Load Limit Data",
      0x0043: "ECS28a Set Load Limit Configurations - General Settings",
      0x0044: "ECS28b Set Load Limit Configuration Counter Reset",
      0x0045: "ECS29a Set Voltage Configurations on ESME",
      0x0046: "ECS30 Set Billing Calendar on the ESME",
      0x0047: "ECS34 Set Instantaneous Power Threshold Configuration",
      0x0048: "ECS35a Read ESME Event Log",
      0x0049: "ECS35b Read ESME Security Log",
      0x004A: "ECS37 Set Maximum Demand Configurable Time Period",
      0x004B: "ECS38 Update Randomised Offset Limit",
      0x004C: "ECS39a Set MPAN Value on the ESME",
      0x004D: "ECS39b Set Export MPAN Value on the ESME",
      0x004E: "ECS40 Read MPAN Value on the ESME",
      0x004F: "ECS42 Remotely Close the Load Switch on the ESME",
      0x0050: "ECS43 Remotely Open the Load Switch on the ESME",
      0x0051: "ECS44 Arm Load Switch in ESME",
      0x0052: "ECS45 Read Status of Load Switch in the ESME",
      0x0053: "ECS46a Set HC ALCS or ALCS Labels in ESME",
      0x0054: "ECS46c Set HC ALCS and ALCS configuration in ESME (excluding labels)",
      0x0055: "ECS47 Set or Reset HC ALCS or ALCS State",
      0x0058: "ECS50 Send CIN to ESME",
      0x0059: "ECS52 Read ESME/Comms Hub Firmware Version",
      0x005A: "ECS57 Reset ESME Maximum Demand Registers",
      0x005E: "ECS61c Read Boost Button Data from ESME",
      0x005F: "ECS62 Set ALCS and Boost Button Association",
      0x0060: "ECS66 Read ESME Daily Consumption Log",
      0x0061: "ECS68 ESME Critical Sensitive Alert (Billing Data Log)",
      0x0062: "ECS70 Set Clock on ESME",
      0x0067: "ECS80 Supply Outage Restore Alert from ESME",
      0x0068: "ECS81 Set Supply Tamper State on ESME",
      0x0069: "ECS82 Read Meter Balance for ESME",
      0x006B: "GCS01a Set Tariff and Price on GSME",
      0x006C: "GCS02 Set GSME Payment Mode to Credit",
      0x006D: "GCS03 Set GSME Payment Mode to Prepayment",
      0x006E: "GCS04 Manage Debt on the GSME",
      0x006F: "GCS05 Update Prepayment Configurations on GSME",
      0x0070: "GCS06 Activate Emergency Credit Remotely on GSME",
      0x0071: "GCS07 Send Message to GSME",
      0x0072: "GCS09 Set Change of Tenancy date on GPF",
      0x0073: "GCS11 Disable Privacy PIN Protection on GSME",
      0x0074: "GCS13a Read GSME Consumption Register",
      0x0075: "GCS14 Read GSME Prepayment Registers",
      0x0076: "GCS15c Read GSME Billing Data Log (billing calendar triggered)",
      0x0077: "GCS16a Read GSME Daily Read Log",
      0x0078: "GCS17 Read GSME Profile Data Log",
      0x0079: "GCS18 Read Gas Network Data Log",
      0x007B: "GCS21a Read Gas Configuration Data Device Information",
      0x007C: "GCS23 Set CV and Conversion Factor Value(s) on the GSME",
      0x007D: "GCS24 Set Uncontrolled Gas Flow Rate and Supply Tamper State on the GSME",
      0x007E: "GCS25 Set Billing Calendar on the GSME",
      0x007F: "GCS28 Set Clock on GSME",
      0x0080: "GCS31 Start Network Data Log on GSME",
      0x0081: "GCS32 Remotely close the valve in the GSME",
      0x0082: "GCS33 Read GSME Valve Status",
      0x0083: "GCS36 Send CIN to GSME",
      0x0084: "GCS38 Read GSME Firmware Version",
      0x0085: "GCS39 Arm Valve in GSME",
      0x0086: "GCS40a Adjust Prepayment Mode Meter Balance on the GSME",
      0x0087: "GCS41 Set MPRN Value on the GSME",
      0x0088: "GCS44 Write Contact Details on GSME",
      0x0089: "GCS46 Read MPRN on the GSME",
      0x008B: "GCS53 Push Billing Data Log as an Alert",
      0x008C: "GCS59 Restore GPF Device Log",
      0x008D: "GCS60 Read Meter Balance for GSME",
      0x0090: "PCS02 Activate Emergency Credit on GSME from PPMID",
      0x0092: "ECS26i Read Configuration Data Device Information (CHF identity)",
      0x0093: "ECS35c Read CHF Event Log",
      0x0094: "ECS35d Read CHF Security Log",
      0x0096: "GCS16b Read GSME Daily Read log(s) (prepayment)",
      0x0097: "CS01b Apply Prepayment Top Up to a GSME",
      0x009B: "PCS01 Apply Prepayment Top Up to a GSME using PPMID",
      0x009D: "GCS21d Read GSME Configuration Data Device Information (BillingCalendar)",
      0x009E: "GCS21e Read GSME/GPF Configuration Data Device Information (device identity)",
      0x009F: "GCS21f Read GSME Tariff Data",
      0x00A0: "GCS61 Read Gas Daily Consumption Log",
      0x00A1: "CS10b Read ZigBee Device Security Log",
      0x00A2: "ECS01b Set Price on ESME",
      0x00A3: "GCS01b Set Price on GSME",
      0x00AB: "CS03A2 Method A Join (non Meter)",
      0x00AC: "ECS25a Set Alert Behaviours - ESME - Supplier",
      0x00AD: "GCS20 Set Alert Behaviours - GSME",
      0x00AE: "ECS29b Set Voltage Configurations on ESME - 3ph",
      0x00AF: "CS03C Method C Join",
      0x00B0: "ECS25b Set Alert Behaviours - ESME - Network Operator",
      0x00B2: "GCS62 Backup GPF Device Log",
      0x00B3: "ECS04b Reset Meter Balance on the ESME",
      0x00B4: "GCS40b Reset Prepayment Mode Meter Balance on the GSME",
      0x00B5: "GCS21b Read GSME Configuration Data Prepayment",
      0x00B6: "GCS13c Read GSME Register (TOU)",
      0x00B7: "ECS01c Set Tariff and Price on ESME secondary",
      0x00B8: "GCS13b Read GSME Block Counters",
      0x00B9: "ECS35e Read ESME Power Event Log",
      0x00BA: "ECS35f Read ALCS Event Log",
      0x00BB: "ECS61a Read HC ALCS and ALCS Data from ESME",
      0x00BC: "ECS23b Read Voltage Operational Data - 3 Phase",
      0x00BD: "ECS24b Read ESME Tariff Data - second element",
      0x00BE: "ECS26j Read ESME Configuration Data Device Information (Payment Mode)",
      0x00BF: "GCS21j Read GSME Configuration Data Device Information (Payment Mode)",
      0x00C0: "GCS40c Adjust Credit Mode Meter Balance on the GSME",
      0x00C1: "ECS15c Clear ALCS Event Log",
      0x00C2: "GCS40d Reset Credit Mode Meter Balance on the GSME",
      0x00C3: "GCS15b Read GSME Billing Data Log (change of mode / tariff triggered)",
      0x00C4: "GCS15d Read GSME Billing Data Log (payment-based debt payments)",
      0x00C5: "GCS15e Read GSME Billing Data Log (prepayment credits)",
      0x00C6: "ECS26k Read ESME Configuration Voltage Data - 3 phase",
      0x00C7: "ECS01d Set Price on ESME secondary",
      0x00C9: "ECS20d Read ESME Billing Data Log (prepayment credits)",
      0x00CA: "Futured Dated Firmware Activation Alert",
      0x00CB: "Futured Dated Update Security Credentials Alert",
      0x00CC: "Future Dated Execution Of Instruction Alert (DLMS COSEM)",
      0x00CD: "Future Dated Execution Of Instruction Alert (GBZ)",
      0x00CE: "Firmware Distribution Receipt Alert (ESME)",
      0x00CF: "Firmware Distribution Receipt Alert (GSME)",
      0x00D1: "ECS29c Set Voltage Configurations on ESME without counter reset",
      0x00D2: "ECS29d Set Voltage Configurations on polyphase ESME without counter reset",
      0x00D3: "ECS29e Reset RMS Voltage Counters on ESME",
      0x00D4: "ECS29f Reset RMS Voltage Counters on polyphase ESME",
      0x00D5: "Failure to Deliver Remote Party Message to ESME Alert",
      0x00D7: "ECS30a Set Billing Calendar on the ESME - all periodicities",
      0x00D8: "GCS25a Set Billing Calendar on the GSME - all periodicities",
      0x00D9: "ECS26l Read ESME Configuration Data Device Information (Billing Calendar - all periodicities)",
      0x00DA: "GCS21k Read GSME Configuration Data Device Information (BillingCalendar - all periodicities)",
      0x00DB: "ECS48 Configure daily resetting of Tariff Block Counter Matrix",
      0x00DE: "ECS08a Update Prepayment Configuration on ESME",
      0x00EA: "ECS25a1 Set Event Behaviours - ESME to HAN Device - Supplier",
      0x00EB: "ECS25a2 Set Event Behaviours - ESME audible alarm - Supplier",
      0x00EC: "ECS25a3 Set Event Behaviours - ESME logging - Supplier",
      0x00ED: "ECS25b3 Set Event Behaviours - ESME logging - Network Operator",
      0x00EE: "ECS25r1 Read non-critical event and alert behaviours - ESME - Supplier",
      0x00EF: "ECS25r2 Read non-critical event and alert behaviours - ESME - Network Operator",
      0x00F0: "Meter Integrity Issue Warning Alert - ESME",
      0x00F1: "GCS20r Read non-critical event and alert behaviours - GSME - Supplier",
      0x00F2: "Meter Integrity Issue Warning Alert - GSME",
      0x00F9: "ECS26m Read ESME Configuration Data Device Information (identity,  type and supply tamper state)",
      0x00FA: "ECS26n Read CHF Configuration Data Device Information (CH identity and type)",
      0x00FB: "GCS21m Read GSME Configuration Data Device Information (identity, type and supply tamper / depletion state)",
      0x00FC: "GCS24a Set Uncontrolled Gas Flow Rate and Supply Tamper State on the GSME (SMETS4)",
      0x00FD: "ECS35g Read ALCS Event Log",
      0x00FE: "CCS07 Read CHF Device Logs",
      0x0100: "CS02b Update Security Credentials (rootBySupplier)",
      0x0101: "CS02b Update Security Credentials (rootByWanProvider)",
      0x0102: "CS02b Update Security Credentials (supplierBySupplier)",
      0x0103: "CS02b Update Security Credentials (networkOperatorByNetworkOperator)",
      0x0104: "CS02b Update Security Credentials (accessControlBrokerByACB)",
      0x0105: "CS02b Update Security Credentials (wanProviderByWanProvider)",
      0x0106: "CS02b Update Security Credentials (transCoSByTransCoS)",
      0x0107: "CS02b Update Security Credentials (supplierByTransCoS)",
      0x0108: "CS02b Update Security Credentials (anyExceptAbnormalRootByRecovery)",
      0x0109: "CS02b Update Security Credentials (anyByContingency)",
      0x010A: "DBCH01 Read CHF Sub GHz Channel",
      0x010B: "DBCH02 Read CHF Sub GHz Channel Log",
      0x010C: "DBCH03 Read CHF Sub GHz Configuration",
      0x010D: "DBCH04 Set CHF Sub GHz Configuration",
      0x010E: "DBCH05 Request CHF Sub GHz Channel Scan",
      0x010F: "CCS06 Read CHF device log and check HAN communications",
      0x0110: "DBCH06 Limited Duty Cycle Action Taken Sub GHz Alert",
      0x0111: "DBCH07 Sub GHz Sub GHz Channel Changed Sub GHz Alert",
      0x0112: "DBCH08 Sub GHz Channel Scan Request Assessment Outcome Sub GHz Alert",
      0x0113: "DBCH09 Sub GHz Configuration Changed Sub GHz Alert",
      0x0114: "DBCH10 Message Discarded Due to Duty Cycle Management Sub GHz Alert",
      0x0115: "DBCH11 No More Sub GHz Device Capacity Sub GHz Alert",
      0x0116: "PECS01 Apply Prepayment Top Up to an ESME using PPMID",
      0x0117: "PECS02 Activate Emergency Credit on ESME from PPMID",
      0x0118: "PECS03 Request to Enable ESME Supply from PPMID",
      0x0119: "HECS01 Request Control of a HAN Connected Auxiliary Load Control Switch from HCALCS",
      0x1000: "Generic Critical Alert",
      0x1001: "Generic Non Critical Alert",
    };
    var messageCode = parseNumber(x, 2);
    putBytes(name, getBytes(x, 2), usecases[messageCode]);
    return messageCode;
  }

  function getAlertCodeName(/*int*/ alertCode) {
    var names = {
      0x8002: "Average RMS Voltage above Average RMS Over Voltage Threshold (current value above threshold; previous value below threshold)",
      0x8003: "Average RMS Voltage above Average RMS Over Voltage Threshold  on Phase 1 (current value above threshold; previous value below threshold)",
      0x8004: "Average RMS Voltage above Average RMS Over Voltage Threshold  on Phase 2 (current value above threshold; previous value below threshold)",
      0x8005: "Average RMS Voltage above Average RMS Over Voltage Threshold  on Phase 3 (current value above threshold; previous value below threshold)",
      0x8006: "Average RMS Voltage below Average RMS Under Voltage Threshold (current value below threshold; previous value above threshold)",
      0x8007: "Average RMS Voltage below Average RMS Under Voltage Threshold on Phase 1 (current value below threshold; previous value above threshold)",
      0x8008: "Average RMS Voltage below Average RMS Under Voltage Threshold on Phase 2 (current value below threshold; previous value above threshold)",
      0x8009: "Average RMS Voltage below Average RMS Under Voltage Threshold on Phase 3 (current value below threshold; previous value above threshold)",
      0x8010: "Over Current",
      0x8011: "Over Current L1",
      0x8016: "Over Current L2",
      0x8013: "Over Current L3",
      0x8014: "Power Factor Threshold Below",
      0x8015: "Power Factor Threshold Ok",
      0x8020: "RMS Voltage above Extreme Over Voltage Threshold (voltage rises above for longer than the configurable period)",
      0x8021: "RMS Voltage above Extreme Over Voltage Threshold on Phase 1 (voltage rises above for longer than the configurable period)",
      0x8022: "RMS Voltage above Extreme Over Voltage Threshold on Phase 2 (voltage rises above for longer than the configurable period)",
      0x8023: "RMS Voltage above Extreme Over Voltage Threshold on Phase 3 (voltage rises above for longer than the configurable period)",
      0x8024: "RMS Voltage above Voltage Swell Threshold (voltage rises above for longer than the configurable period)",
      0x8025: "RMS Voltage above Voltage Swell Threshold on Phase 1 (voltage rises above for longer than the configurable period)",
      0x8026: "RMS Voltage above Voltage Swell Threshold on Phase 2 (voltage rises above for longer than the configurable period)",
      0x8027: "RMS Voltage above Voltage Swell Threshold on Phase 3 (voltage rises above for longer than the configurable period)",
      0x8028: "RMS Voltage below Extreme Under Voltage Threshold (voltage falls below for longer than the configurable period)",
      0x8029: "RMS Voltage below Extreme Under Voltage Threshold on Phase 1 (voltage falls below for longer than the configurable period)",
      0x802A: "RMS Voltage below Extreme Under Voltage Threshold on Phase 2 (voltage falls below for longer than the configurable period)",
      0x802B: "RMS Voltage below Extreme Under Voltage Threshold on Phase 3 (voltage falls below for longer than the configurable period)",
      0x802C: "RMS Voltage below Voltage Sag Threshold (voltage falls below for longer than the configurable period)",
      0x802D: "RMS Voltage below Voltage Sag Threshold on Phase 1 (voltage falls below for longer than the configurable period)",
      0x802E: "RMS Voltage below Voltage Sag Threshold on Phase 2 (voltage falls below for longer than the configurable period)",
      0x802F: "RMS Voltage below Voltage Sag Threshold on Phase 3 (voltage falls below for longer than the configurable period)",
      0x8071: "GPF Device Log Changed",
      0x8085: "Average RMS Voltage below Average RMS Over Voltage Threshold (current value below threshold; previous value above threshold)",
      0x8086: "Average RMS Voltage below Average RMS Over Voltage Threshold on Phase 1 (current value below threshold; previous value above threshold)",
      0x8087: "Average RMS Voltage below Average RMS Over Voltage Threshold on Phase 2 (current value below threshold; previous value above threshold)",
      0x8088: "Average RMS Voltage below Average RMS Over Voltage Threshold on Phase 3 (current value below threshold; previous value above threshold)",
      0x8089: "Average RMS Voltage above Average RMS Under Voltage Threshold (current value above threshold; previous value below threshold)",
      0x808A: "Average RMS Voltage above Average RMS Under Voltage Threshold on Phase 1 (current value above threshold; previous value below threshold)",
      0x808B: "Average RMS Voltage above Average RMS Under Voltage Threshold on Phase 2 (current value above threshold; previous value below threshold)",
      0x808C: "Average RMS Voltage above Average RMS Under Voltage Threshold on Phase 3 (current value above threshold; previous value below threshold)",
      0x808D: "RMS Voltage above Extreme Over Voltage Threshold (voltage returns below for longer than the configurable period)",
      0x808E: "RMS Voltage above Extreme Over Voltage Threshold on Phase 1 (voltage returns below for longer than the configurable period)",
      0x808F: "RMS Voltage above Extreme Over Voltage Threshold on Phase 2 (voltage returns below for longer than the configurable period)",
      0x8090: "RMS Voltage above Extreme Over Voltage Threshold on Phase 3 (voltage returns below for longer than the configurable period)",
      0x8091: "RMS Voltage above Voltage Swell Threshold (voltage returns below for longer than the configurable period)",
      0x8092: "RMS Voltage above Voltage Swell Threshold on Phase 1 (voltage returns below for longer than the configurable period)",
      0x8093: "RMS Voltage above Voltage Swell Threshold on Phase 2 (voltage returns below for longer than the configurable period)",
      0x8094: "RMS Voltage above Voltage Swell Threshold on Phase 3 (voltage returns below for longer than the configurable period)",
      0x8095: "RMS Voltage below Extreme Under Voltage Threshold (voltage returns above for longer than the configurable period)",
      0x8096: "RMS Voltage below Extreme Under Voltage Threshold on Phase 1 (voltage returns above for longer than the configurable period)",
      0x8097: "RMS Voltage below Extreme Under Voltage Threshold on Phase 2 (voltage returns above for longer than the configurable period)",
      0x8098: "RMS Voltage below Extreme Under Voltage Threshold on Phase 3 (voltage returns above for longer than the configurable period)",
      0x8099: "RMS Voltage below Voltage Sag Threshold (voltage returns above for longer than the configurable period)",
      0x809A: "RMS Voltage below Voltage Sag Threshold on Phase 1 (voltage returns above for longer than the configurable period)",
      0x809B: "RMS Voltage below Voltage Sag Threshold on Phase 2 (voltage returns above for longer than the configurable period)",
      0x809C: "RMS Voltage below Voltage Sag Threshold on Phase 3 (voltage returns above for longer than the configurable period)",
      0x810D: "Combined Credit Below Low Credit Threshold (prepayment mode)",
      0x810E: "Credit Added Locally",
      0x8119: "Emergency Credit Has Become Available (prepayment mode)",
      0x8154: "Immediate HAN Interface Command Received and Successfully Actioned",
      0x8155: "Immediate HAN Interface Command Received but not Successfully Actioned",
      0x8168: "Supply Disabled then Armed - Activate Emergency Credit triggered",
      0x8183: "Device joined SMHAN",
      0x8184: "Valve tested",
      0x819D: "GSME Command Not Retrieved",
      0x819E: "Tap Off Message Response or Alert Failure",
      0x81A0: "Smart Meter Integrity Issue - Warning",
      0x81A1: "Battery Cover Closed",
      0x81A2: "CH Connected to ESME",
      0x81A3: "CH Disconnected from ESME",
      0x81A4: "Close Tunnel Command Rejected",
      0x81A5: "Communication From Local Port (e.g. Optical)",
      0x81A6: "Customer Acknowledged Message on HAN Device",
      0x81A7: "Debt Collection Completed - Time Debt 1",
      0x81A8: "Debt Collection Completed - Time Debt 2",
      0x81A9: "Debt Collection Completed - Payment Debt",
      0x81AA: "Emergency Credit Exhausted",
      0x81AB: "Emergency Credit Activated",
      0x81AC: "Error Measurement Fault",
      0x81AD: "Error Metrology Firmware Verification Failure",
      0x81AE: "Error Non Volatile Memory",
      0x81AF: "Error Program Execution",
      0x81B0: "Error Program Storage",
      0x81B1: "Error RAM",
      0x81B2: "Error Unexpected Hardware Reset",
      0x81B3: "Error Watchdog ",
      0x81B4: "Excess Gas Flow Beyond Meter Capacity",
      0x81B5: "Flow Sensor Detects Air in Gas Flow",
      0x81B6: "Flow Sensor Detects Reverse Flow of Gas",
      0x81B7: "Incorrect phase sequencing",
      0x81B8: "Incorrect Polarity",
      0x81B9: "Meter Cover Closed",
      0x81BA: "Request Tunnel Command Rejected",
      0x81BB: "Reverse Current",
      0x81BC: "Strong Magnetic Field Removed",
      0x81BD: "Supply Connect Failure (Valve or Load Switch)",
      0x81BE: "Supply Disabled Then Locked - Supply Tamper State Cause",
      0x81BF: "Supply Disabled Then Armed - Uncontrolled Gas Flow Rate",
      0x81C0: "Supply Disconnect Failure (Valve or Load Switch)",
      0x81C1: "Terminal Cover Closed",
      0x81C2: "Tilt Tamper Ended",
      0x81C3: "Tilt Tamper",
      0x81C4: "UTRN Manual Entry Suspended",
      0x81C5: "UTRN rejected as locked out",
      0x81C6: "Clock not adjusted (outside tolerance)",
      0x8F01: "Active Power Import above Load Limit Threshold",
      0x8F0A: "Billing Data Log Updated",
      0x8F0C: "Clock not adjusted (adjustment greater than 10 seconds)",
      0x8F0F: "Credit Below Disablement Threshold (prepayment mode)",
      0x8F12: "CHF Device Log Changed",
      0x8F1B: "Firmware Verification Failed At Power On",
      0x8F1C: "Firmware Verification Failed",
      0x8F1D: "GSME Power Supply Loss",
      0x8F1E: "Integrity check of content or format of command failed",
      0x8F1F: "Low Battery Capacity",
      0x8F20: "Limited Duty Cycle Action Taken",
      0x8F21: "Duty Cycle fallen below Normal-Limited Duty Cycle Threshold",
      0x8F22: "Critical Duty Cycle Action Taken",
      0x8F23: "Duty Cycle fallen below Limited-Critical Duty Cycle Threshold",
      0x8F24: "Regulated Duty Cycle Action Taken",
      0x8F25: "Duty Cycle fallen below Critical-Regulated Duty Cycle Threshold",
      0x8F26: "Sub GHz Channel Changed",
      0x8F27: "Sub GHz Channel Scan initiated",
      0x8F28: "Sub GHz Channel Scan Request Assessment Outcome",
      0x8F29: "Three Lost GSME Searches Failed",
      0x8F2A: "Sub GHz Configuration Changed",
      0x8F2B: "Sub GHz Channel not changed due to Frequency Agility Parameters",
      0x8F2C: "Message Discarded Due to Duty Cycle Management",
      0x8F2D: "No More Sub GHz Device Capacity",
      0x8F30: "Source Does not have Authority for Command",
      0x8F32: "Supply Armed",
      0x8F33: "Supply Disabled then Armed - Load Limit triggered",
      0x8F34: "Supply Enabled after Load Limit Restoration Period (Load Limit triggered)",
      0x8F35: "Supply Outage Restored",
      0x8F36: "Supply Outage Restored - Outage >= 3 minutes",
      0x8F37: "Supply Outage Restored on Phase 1",
      0x8F38: "Supply Outage Restored on Phase 1 Restored - Outage >= 3 minutes",
      0x8F39: "Supply Outage Restored on Phase 2 Restored",
      0x8F3A: "Supply Outage Restored on Phase 2 Restored - Outage >= 3 minutes",
      0x8F3B: "Supply Outage Restored on Phase 3 Restored",
      0x8F3C: "Supply Outage Restored on Phase 3 Restored - Outage >= 3 minutes",
      0x8F3D: "Trusted Source Authentication Failure",
      0x8F3E: "Unauthorised Communication Access attempted",
      0x8F3F: "Unauthorised Physical Access - Tamper Detect",
      0x8F43: "Change in the executing Firmware version",
      0x8145: "Clock adjusted (within tolerance)",
      0x8F47: "Credit would cause Meter Balance to exceed  Maximum Meter Balance Threshold",
      0x8F48: "Device joining failed",
      0x8F49: "Device joining succeeded ",
      0x8F4A: "Device Unjoining failed ",
      0x8F4B: "Device Unjoining succeeded ",
      0x8F4C: "Device's own Digital Signing Certificate replacement failed",
      0x8F4D: "Device's own Digital Signing Certificate replacement succeeded",
      0x8F4E: "Device's own Key Agreement Certificate replacement failed",
      0x8F4F: "Device's own Key Agreement Certificate replacement succeeded",
      0x8F51: "Duplicate UTRN entered",
      0x8F52: "Event Log Cleared",
      0x8F53: "Failed Authentication or Authorisation not covered by other codes",
      0x8F57: "Supply interrupted",
      0x8F58: "Supply interrupted on Phase 1",
      0x8F59: "Supply interrupted on Phase 2",
      0x8F5A: "Supply interrupted on Phase 3",
      0x8F5B: "UTRN exceeds Maximum Credit Threshold",
      0x8F60: "Unusual numbers of malformed, out-of-order or unexpected Commands received",
      0x8161: "User Interface Command Input and Successfully Actioned",
      0x8162: "User Interface Command Input but not Successfully Actioned",
      0x8F63: "UTRN not Authentic",
      0x8F64: "UTRN not for this Device",
      0x8F66: "Future-date HAN Interface Command Successfully Actioned",
      0x8F67: "Future-date HAN Interface Command not Successfully Actioned",
      0x8F69: "Device commissioned",
      0x8F70: "Update Security Credentials ",
      0x8F72: "Firmware Verification Successful",
      0x8F73: "Unauthorised Physical Access - Battery Cover Removed",
      0x8F74: "Unauthorised Physical Access - Meter Cover Removed",
      0x8F75: "Unauthorised Physical Access - Strong Magnetic field",
      0x8F76: "Unauthorised Physical Access - Terminal Cover Removed",
      0x8F77: "Unauthorised Physical Access - Second Terminal Cover Removed",
      0x8F78: "Unauthorised Physical Access - Other",
      0x8F82: "Remaining Battery Capacity reset",
      0x8F83: "Disablement of Supply due to insufficient credit has been suspended ",
      0x8F84: "Failure to Deliver Remote Party Message to ESME",
    };
    return names[alertCode];
  }

  // ASN.1 DER Payloads

  // CS02a Provide Security Credentials

  function parseProvideSecurityCredentialDetailsCommand(x) {
    var s = parseSequence(x, "Provide Security Credential Details Command");
    parseTrustAnchorCellIdentifier(s, "Authorising Remote Party TA Cell Identifier");
    parseSequenceOf(s, "Remote Party Roles Credentials Required", parseRemotePartyRole);
  }

  function parseProvideSecurityCredentialDetailsResponse(x) {
    var sequenceOf = parseSequence(x, "Provide Security Credential Details Response");
    while (sequenceOf.index < sequenceOf.end) {
      var rpDetails = parseSequence(sequenceOf, "Remote Party Details");
      parseRemotePartyRole(rpDetails);
      parseStatusCode(rpDetails);
      if (rpDetails.index < rpDetails.end) {
        parseSeqNumber(rpDetails, "Current Seq Number");
        var tacDetails = parseSequence(rpDetails, "Trust Anchor Cell Details");
        while (tacDetails.index < tacDetails.end) {
          var contents = parseSequence(tacDetails, "Trust Anchor Cell Contents");
          parseKeyUsage(contents);
          parseCellUsage(contents);
          parseDerOctetString(contents, "Subject Unique ID");
          parseDerOctetString(contents, "Subject Key Identifier");
        }
      }
    }
  }

  // CS02b Update Security Credentials

  function parseUpdateSecurityCredentialsCommand(x) {
    var s = parseSequence(x, "Update Security Credentials Command");
    parseAuthorisingRemotePartyControl(s);
    parseSequenceOf(s, "Replacements", parseTrustAnchorReplacement);
    parseSequenceOf(s, "Certification Path Certificates", parseCertificate);
    if (isPresent(s, 0x18)) parseGeneralizedTime(s, "Execution Date Time");
  }

  function parseUpdateSecurityCredentialsResponse(x) {
    var s = parseSequence(x, "Update Security Credentials Response");
    parseNull(s, "Command Accepted");
    if (isPresent(s, 0x30)) parseUpdateSecurityCredentialsExecutionOutcome(s);
  }

  function parseUpdateSecurityCredentialsAlert(x) {
    var s = parseSequence(x, "Update Security Credentials Alert");
    parseAsn1AlertCode(s);
    parseGeneralizedTime(s, "Execution Date Time");
    parseUpdateSecurityCredentialsExecutionOutcome(s);
  }

  function parseUpdateSecurityCredentialsExecutionOutcome(x) {
    var s = parseSequence(x, "Execution Outcome");
    parseSeqNumber(s, "Authorising Remote Party Seq Number");
    parseCredentialsReplacementMode(s);
    parseSequenceOf(s, "Remote Party Seq Number Changes", parseRemotePartySeqNumberChange);
    parseSequenceOf(s, "Replacement Outcomes", parseReplacementOutcome);
  }

  function parseReplacementOutcome(x) {
    var s = parseSequence(x, "Replacement Outcome");
    parseTrustAnchorCellIdentifier(s, "Affected Trust Anchor Cell");
    parseStatusCode(s);
    parseDerOctetString(s, "Existing Subject Unique ID");
    parseDerOctetString(s, "Existing Subject Key ID");
    parseDerOctetString(s, "Replacing Subject Unique ID");
    parseDerOctetString(s, "Replacing Subject Key ID");
  }

  // CS02c Issue Security Credentials

  function parseIssueSecurityCredentialsCommand(x) {
    var s = parseSequence(x, "Issue Security Credentials Command");
    parseKeyUsage(s);
  }

  function parseIssueSecurityCredentialsResponse(x) {
    if (isPresent(x, 0x30)) {
      putBytes("Certification Request", x);
    } else {
      parseInteger(x, "Response Code", { 1:"Invalid Key Usage", 2:"Key Pair Generation Failed", 3:"CR Production Failed" });
    }
  }

  // CS02d Update Device Certificate on Device

  function parseUpdateDeviceCertificateCommand(x) {
    parseCertificate(x);
  }

  function parseUpdateDeviceCertificateResponse(x) {
    var responseCodes = {
      0: "Success",
      1: "Invalid Certificate",
      2: "Wrong Device Identity",
      3: "Invalid Key Usage",
      4: "No Corresponding Key Pair Generated",
      5: "Wrong Public Key",
      6: "Certificate Storage Failed",
      7: "Private Key Change Failed",
    };
    parseInteger(x, "Response Code", responseCodes);
  }

  // CS02e Provide Device Certificate from Device

  function parseProvideDeviceCertificateCommand(x) {
    var s = parseSequence(x, "Provide Device Certificate Command");
    parseKeyUsage(s);
  }

  function parseProvideDeviceCertificateResponse(x) {
    if (isPresent(x, 0x30)) {
      parseCertificate(x);
    } else {
      parseInteger(x, "Response Code", { 1:"Invalid Key Usage", 2:"No Certificate Held", 3:"Certificate Retrieval Failure" });
    }
  }

  // CS03XY

  function parseJoinDeviceCommand(x) {
    var s = parseSequence(x, "Join Device Command");
    parseInteger(s, "Join Method and Role", { 0:"Method A Initiator", 1:"Method A Responder", 2:"Method B", 3:"Method C" });
    parseDerOctetString(s, "Entity Id");
    parseDeviceType(s);
    if (s.index < s.end) {
      parseCertificate(s);
    }
  }

  function parseJoindDeviceResponse(x) {
    var responseCodes = {
      0: "Success",
      1: "Invalid Message Code for Join Method and Role",
      2: "Invalid Join Method and Role",
      3: "Incompatible with Existing Entry",
      4: "Device Log Full",
      5: "Write Failure",
      6: "Key Agreement no Resources",
      7: "Key Agreement Unknown Issuer",
      8: "Key Agreement Unsupported Suite",
      9: "Key Agreement Bad Message",
      10: "Key Agreement Bad Key Confirm",
      11: "Invalid or Missing Certificate",
      12: "No Partner Link Key Received",
      13: "No CBKE Response",
    };
    parseInteger(x, "Response Code", responseCodes);
  }

  // CS04XY

  function parseUnjoinDeviceCommand(x) {
    parseDerOctetString(x, "Entity Id");
  }

  function parseUnjoindDeviceResponse(x) {
    parseInteger(x, "Response Code", { 0:"Succes", 1:"Not in Device Log", 2:"Other Failure" });
  }

  // CS06

  function parseActivateFirmwareCommand(x) {
    var s = parseSequence(x, "Activate Firmware Command");
    parseDerOctetString(s, "Manufacturer Image Hash");
    parseSeqNumber(s, "Originator Counter");
    if (s.index < s.end) {
      parseGeneralizedTime(s, "Execution Date Time");
    }
  }

  function parseActivateFirmwareResponse(x) {
    if (isPresent(x, 5)) {
      parseNull(x, "Command Accepted");
    } else {
      parseActivateFirmwareExecutionOutcome(x);
    }
  }

  function parseActivateFirmwareAlert(x) {
    var s = parseSequence(x, "Activate Firmware Alert");
    parseAsn1AlertCode(s);
    parseGeneralizedTime(s, "Execution Date Time");
    parseSeqNumber(s, "Originator Counter");
    parseActivateFirmwareExecutionOutcome(s);
  }

  function parseActivateFirmwareExecutionOutcome(x) {
    var s = parseSequence(x, "Execution Outcome");
    parseInteger(s, "Response Code", { 0:"Success", 1:"No Image Held", 2:"Hash Mismatch", 3:"Activation Failure" });
    parseDerOctetString(s, "Firmware Version");
  }

  // CS07

  function parseReadDeviceJoinDetailsCommand(x) {
    parseNull(x, "Read Device Join Details Command");
  }

  function parseReadDeviceJoinDetailsResponse(x) {
    var s = parseSequence(x, "Read Device Join Details Response");
    parseInteger(s, "Response Code", { 0:"Success", 1:"Read Failure" });
    if (s.index < s.end) {
      parseSequenceOf(s, "Device Log Entries", parseDeviceLogEntry);
    }
  }

  function parseDeviceLogEntry(x) {
    var s = parseSequence(x, "Device Log Entry");
    parseDerOctetString(s, "Device Id");
    parseDeviceType(s);
  }

  // GCS28

  function parseSetTimeCommand(x) {
    var s = parseSequence(x, "Set Time Command");
    parseGeneralizedTime(s, "Validity Interval Start");
    parseGeneralizedTime(s, "Validity Interval End");
  }

  function parseSetTimeResponse(x) {
    var s = parseSequence(x, "Set Time Response");
    parseGeneralizedTime(s, "Device Time");
    parseInteger(s, "Device Time Status", { 0:"Reliable", 1:"Invalid", 2:"Unreliable" });
  }

  // GCS59

  function parseGpfDeviceLogRestoreCommand(x) {
    var s = parseSequence(x, "GPF Device Log Restore Command");
    parseSequenceOf(s, "Device Log Entries", parseDeviceLogEntry);
  }

  function parseGpfDeviceLogRestoreResponse(x) {
    var s = parseSequence(x, "GPF Device Log Restore Response");
    parseSequenceOf(s, "Restore Outcomes", parseGpfDeviceLogRestoreOutcome);
  }

  function parseGpfDeviceLogRestoreOutcome(x) {
    var s = parseSequence(x, "Restore Outcome");
    parseDeviceLogEntry(s);
    var joinResponseCodes = {
      0: "Success",
      1: "Invalid Message Code for Join Method and Role",
      2: "Invalid Join Method and Role",
      3: "Incompatible with Existing Entry",
      4: "Device Log Full",
      5: "Write Failure",
      6: "Key Agreement No Resources",
      7: "Key Agreement Unknown Issuer",
      8: "Key Agreement Unsupported Suite",
      9: "Key Agreement Bad Message",
      10: "Key Agreement Bad Key Confirm",
      11: "Invalid or Missing Certificate",
    };
    parseInteger(s, "Join Response Code", joinResponseCodes);
  }

  // GCS62

  function parseGpfDeviceLogBackupAlert(x) {
    var s = parseSequence(x, "GPF Device Log Backup Alert");
    parseAsn1AlertCode(s);
    parseGeneralizedTime(s, "Backup Date Time");
    parseSequenceOf(s, "Device Log Entries", parseDeviceLogEntry);
  }
  
  
  // Alert 8F84

  function parseRemotePartyMessage(x) {
    var s = parseSequence(x, "Remote Party Message");
    putBytes("Business Originator ID", getBytes(s, 8));
    putBytes("Business Target ID", getBytes(s, 8));
    parseCraFlag(s)
    parseCounter("Originator Counter", s);
  }

  function parseFailureToDeliverRemotePartyToEsme(x) {
    // Failure to Deliver Remote Party Message to ESME Alert
    putBytes("DLMS Data Notification", getBytes(x, 8));
    parseDlmsAlertCode(x);
    parseDlmsOctetString(x, "Time Stamp", true);
    parseRemotePartyMessage(x);
  }


  // GBCS ASN.1 definitions used by multiple use cases

  function parseDeviceType(x) {
    parseInteger(x, "Device Type", { 0:"GSME", 1:"ESME", 2:"CHF", 3:"GPF", 4:"HCALCS", 5:"PPMID", 6:"Type 2" });
  }

  function parseTrustAnchorCellIdentifier(x, name) {
    var s = parseSequence(x, name);
    parseRemotePartyRole(s);
    parseKeyUsage(s);
    parseCellUsage(s);
  }

  function parseRemotePartyRole(x) {
    var values = {
      0: "Root",
      1: "Recovery",
      2: "Supplier",
      3: "Network Operator",
      4: "Access Control Broker",
      5: "Transitional Change of Supplier",
      6: "WAN Provider",
      7: "Issuing Authority",
      127: "Other"
    };
    parseInteger(x, "Remote Party Role", values);
  }

  function parseKeyUsage(x) {
    var bits = {
      0: "Digital Signature",
      4: "Key Agreement",
      5: "Key Cert Sign",
      6: "CRL Sign"
    }
    var length = x.input[x.index + 1];
    var bitstring = x.input[x.index + 3];
    var notes = "";
    for (var i = 0; i < 8; i++) {
      if (bitstring & (0x80 >> i)) {
        if (bits[i]) {
          if (notes)
            notes += " ";
          notes += bits[i];
        }
      }
    }
    putBytes("Key Usage", getBytes(x, 2 + length), notes);
  }

  // CellUsage ::= INTEGER { management (0), prePaymentTopUp (1) } DEFAULT management
  function parseCellUsage(x) {
    if (x.index + 2 < x.end && x.input[x.index] == 2 && x.input[x.index + 1] == 1 && x.input[x.index + 2] == 1) {
      putBytes("Cell Usage", getBytes(x, 3), "Prepayment Top Up");
    } else {
      putBytes("Cell Usage", { index: 0, end: 0 }, "Management (DEFAULT)");
    }
  }

  function parseSeqNumber(x, name) {
    var length = x.input[x.index + 1];
    var bytes = getBytes(x, 2 + length);
    var value = { input: bytes.input, index: bytes.index + 2, end: bytes.end };
    putBytes(name, bytes, getDecimalString(value));
  }

  function parseCredentialsReplacementMode(x) {
    var values = {
      2: "Supplier by Supplier",
      3: "Network Operator by Network Operator",
      4: "ACB by ACB",
      5: "WAN Provider by WAN Provider",
      6: "TransCoS by TransCoS",
      7: "Supplier by TransCoS",
      8: "Any Except Abnormal Root by Recovery",
      9: "Any by Contingency"
    };
    parseInteger(x, "Credentials Replacement Mode", values);
  }

  function parseAuthorisingRemotePartyControl(x) {
    var s = parseSequence(x, "Authorising Remote Party Control");
    parseCredentialsReplacementMode(s);
    if (isPresent(s, 0x80)) parseDerOctetString(s, "Plaintext Symmetric Key");
    if (isPresent(s, 0x81)) parseInteger(s, "Apply Time Based CPV Checks", { 0: "Apply", 1: "Disapply" });
    if (isPresent(s, 0xA2)) parseTrustAnchorCellIdentifier(s, "Authorising Remote Party TA Cell Identifier");
    parseSeqNumber(s, "Authorising Remote Party Seq Number");
    if (isPresent(s, 0x84)) parseSeqNumber(s, "New Remote Party Floor Seq Number");
    if (isPresent(s, 0xA5)) parseSequenceOf(s, "New Remote Party Specialist Floor Seq Number", parseSpecialistSeqNumber);
    if (isPresent(s, 0xA6)) parseSequenceOf(s, "Other Remote Party Seq Number Changes", parseRemotePartySeqNumberChange);
  }

  function parseSpecialistSeqNumber(x) {
    var s = parseSequence(x, "Specialist Seq Number");
    parseInteger(s, "Seq Number Usage", { 0: "Prepayment Top Up" });
    parseSeqNumber(s, "Seq Number");
  }

  function parseRemotePartySeqNumberChange(x) {
    var s = parseSequence(x, "Remote Party Seq Number Change");
    parseRemotePartyRole(s);
    parseSeqNumber(s, "Floor Seq Number");
    if (isPresent(s, 0x30)) parseSequenceOf(s, "Specialist Floor Seq Number", parseSpecialistSeqNumber);
  }

  function parseTrustAnchorReplacement(x) {
    var s = parseSequence(x, "Trust Anchor Replacement");
    parseCertificate(s);
    parseTrustAnchorCellIdentifier(s, "Target Trust Anchor Cell");
  }

  // StatusCode ::= ENUMERATED { success (0), ... }
  // Used in the CS02a and CS02b responses
  function parseStatusCode(x) {
    var values = {
      0: "Success",
      5: "Bad Certificate",
      10: "No Trust Anchor",
      17: "Insufficient Memory",
      25: "Trust Anchor Not Found",
      30: "Resources Busy",
      127: "Other"
    };
    parseEnumerated(x, "Status Code", values);
  }

  function getCertificateDecoder(name, x, n) {
    var bin = x.input.slice(x.index, x.index + n);
    var base64 = btoa(String.fromCharCode.apply(null, bin));
    var url = "https://ssldecoder.daniel-ruf.de/?csr=-----BEGIN+CERTIFICATE-----%0D%0A" + encodeURIComponent(base64) + "%0D%0A-----END+CERTIFICATE-----";
    return getLink(name, url);
  }

  function parseCertificate(x, name) {
    var lenSz = parseLength(x, 1);
    var decoder = getCertificateDecoder("Decode certificate", x, 1 + lenSz.size + lenSz.length);
    putBytes(name || "Certificate", getBytes(x, 1 + lenSz.size + lenSz.length), decoder);
  }

  // ASN.1 Types

  function parseSequence(x, name) {
    var lenSz = parseLength(x, 1);
    putBytes(name, getBytes(x, 1 + lenSz.size));
    return getBytes(x, lenSz.length);
  }

  function parseSequenceOf(x, name, parse) {
    var s = parseSequence(x, name);
    while (s.index < s.end) {
      parse(s);
    }
  }

  function parseInteger(x, name, values) {
    var value = 0;
    var length = x.input[x.index + 1];
    value = parseNumber(x, length, 2);
    putBytes(name, getBytes(x, 2 + length), values && values[value] || value);
  }

  function parseAsn1AlertCode(x) {
    var alertCode = 0;
    var length = x.input[x.index + 1];
    alertCode = parseNumber(x, length, 2);
    putBytes("Alert Code", getBytes(x, 2 + length), getAlertCodeName(alertCode));
  }

  function parseEnumerated(x, name, values) {
    parseInteger(x, name, values);
  }

  function parseDerOctetString(x, name) {
    var lenSz = parseLength(x, 1);
    putBytes(name, getBytes(x, 1 + lenSz.size + lenSz.length));
  }

  function parseGeneralizedTime(x, name) {
    var length = x.input[x.index + 1];
    var time = "";
    for (var i = 0; i < length; i++) {
      var c = x.input[x.index + 2 + i];
      if (i == 4 || i == 6)
        time += "-";
      else if (i == 8 || i == 14)
        time += " ";
      else if (i == 10 || i == 12)
        time += ":";
      time += String.fromCharCode(c);
    }
    putBytes(name, getBytes(x, 2 + length), time);
  }

  function parseNull(x, name) {
    putBytes(name, getBytes(x, 2));
  }

  function isPresent(x, tag) {
    return x.index < x.end && x.input[x.index] == tag;
  }

  // DLMS Payloads

  function parseDlmsAccessRequest(x) {
    putBytes("DLMS Access Request", getBytes(x, 6));
    parseDlmsSequenceOf(x, "List of Access Request Specifications", parseDlmsAccessRequestSpecification);
    // TODO: check for IC 0x001E (Data Protection), Method 1 (Get Protected Attributes)
    parseDlmsSequenceOf(x, "List of Data", parseDlmsData);
  }

  function parseDlmsAccessResponse(x, messageCode) {
    putBytes("DLMS Access Response", getBytes(x, 7));
    switch (messageCode) {
      case 0x0027:  // ECS17b
      case 0x0029:  // ECS17d
      case 0x002A:  // ECS17e
      case 0x002D:  // ECS19
      case 0x002F:  // ECS20b
      case 0x0030:  // ECS20c
      case 0x0033:  // ECS21a
      case 0x0034:  // ECS21b
      case 0x0037:  // ECS22b
      case 0x0060:  // ECS66
        parseDlmsSequenceOf(x, "List of Access Response Data", parseDlmsProtectedAttributesResponse);
        break;
      default:
        parseDlmsSequenceOf(x, "List of Access Response Data", parseDlmsData);
        break;
    }
    parseDlmsSequenceOf(x, "List of Access Response Specification", parseDlmsAccessResponseSpecification);
  }

  function parseDlmsDataNotificationGbcsAlert(x) {
    putBytes("DLMS Data Notification", getBytes(x, 8));
    parseDlmsAlertCode(x);
    parseDlmsOctetString(x, "Time Stamp", true);
    while (x.index < x.end) {
      parseDlmsData(x);
    }
  }

  function parseDlmsAccessRequestSpecification(x, idx) {
    var choice = x.input[x.index];
    if (choice == 1) {
      putBytes("Access Request Specification", getBytes(x, 1), "Access Request Get " + idx);
      parseDlmsCosemAttributeDescriptor(x);
    } else if (choice == 2) {
      putBytes("Access Request Specification", getBytes(x, 1), "Access Request Set " + idx);
      parseDlmsCosemAttributeDescriptor(x);
    } else if (choice == 3) {
      putBytes("Access Request Specification", getBytes(x, 1), "Access Request Action " + idx);
      parseDlmsCosemMethodDescriptor(x);
    } else if (choice == 4) {
      putBytes("Access Request Specification", getBytes(x, 1), "Access Request Get with Selection " + idx);
      parseDlmsCosemAttributeDescriptor(x);
      parseDlmsSelectiveAccessDescriptor(x);
    } else {
      throw "TODO: Access-Request-Specification CHOICE " + choice;
    }
  }

  function parseDlmsAccessResponseSpecification(x, idx) {
    var choice = x.input[x.index];
    if (choice == 1) {
      putBytes("Access Response Specification", getBytes(x, 1), "Access Response Get " + idx);
      parseDlmsDataAccessResult(x);
    } else if (choice == 2) {
      putBytes("Access Response Specification", getBytes(x, 1), "Access Response Set " + idx);
      parseDlmsDataAccessResult(x);
    } else if (choice == 3) {
      putBytes("Access Response Specification", getBytes(x, 1), "Access Response Action " + idx);
      parseDlmsActionResult(x);
    } else {
      throw "TODO: Access-Response-Specification CHOICE " + choice;
    }
  }

  function parseDlmsFutureDatedAlert(x) {
    putBytes("DLMS Data Notification (Future Dated Alert)", getBytes(x, 8));
    parseDlmsAlertCode(x);
    parseDlmsOctetString(x, "Time Stamp", true);
    putBytes("Future Dated Alert Payload", getBytes(x, 2));
    parseMessageCode("Message Code", x);
    parseCounter("Originator Counter", x);
    parseDlmsCosemAttributeDescriptor(x);
  }

  function parseDlmsFirmwareDistributionReceiptAlert(x) {
    putBytes("DLMS Data Notification", getBytes(x, 8));
    parseDlmsAlertCode(x);
    parseDlmsOctetString(x, "Time Stamp", true);
    parseDlmsOctetString(x, "Calculated Manufacturer Hash", true);
  }

  function parseDlmsBillingDataLogAlert(x) {
    putBytes("DLMS Data Notification", getBytes(x, 8));
    parseDlmsAlertCode(x);
    parseDlmsOctetString(x, "Time Stamp", true);
    parseDlmsProtectedData(x);
  }

  function decryptPayloadWithKey(ciphertextTag, /* Uint8Array(16) */ aesKey, doneCb) {

    function getAesKey(key) {
      return window.crypto.subtle.importKey(
        "raw",
        key,
        { name: "AES-GCM" },
        true, //extractable
        [ "decrypt" ]
      );
    }

    function decrypt(key, ciphertext) {
      var iv = new Uint8Array(12);
      iv.set(cipherInfo.origSysTitle, 0);
      iv.set([0, 0, 0, 0], 8);
      return window.crypto.subtle.decrypt(
        {
          name: "AES-GCM",
          iv: iv,
          additionalData: new Uint8Array([0x31]),
          tagLength: 96,
        },
        key,
        ciphertext
      );
    }

    function update(ok, value) {
      var anchor = document.getElementById("decrypted-payload");
      output = "";
      sensitive = true;
      putSeparator("Decrypted DLMS Payload");
      if (ok) {
        var yy = { input: new Uint8Array(value), index: 0, end: value.byteLength };
        doneCb(yy);
      } else {
        console.log(value);
        putBytes("Error decrypting", {end: 0, index: 0});
      }
      // update DOM
      anchor.outerHTML = output;
    }

    getAesKey(aesKey)
      .then(function (key) { return decrypt(key, ciphertextTag); })
      .then(function (p) { update(true, p); })
      .catch(function (e) { update(false, e); });
  }

  function deriveKeyFromPair(prvKey, pubKey, doneCb) {

    // Not in Firefox yet https://bugzilla.mozilla.org/show_bug.cgi?id=1048931
    function getPrivKey(pem) {
      // fetch the part of the PEM string between header and footer
      const pemHeader = "-----BEGIN PRIVATE KEY-----";
      const pemFooter = "-----END PRIVATE KEY-----";
      const pemContents = pem.trim().substring(pemHeader.length, pem.length - pemFooter.length);
      // base64 decode the string to get the binary data
      const binaryDerString = window.atob(pemContents);
      // convert from a binary string to an ArrayBuffer
      const binaryDer = str2u8array(binaryDerString);

      return window.crypto.subtle.importKey(
        "pkcs8",
        binaryDer,
        {
          name: "ECDH",
          namedCurve: "P-256"
        },
        false,
        [ "deriveBits", "deriveKey" ]
      );
    }

    function getPubKey(pubRaw) {
      const pubHeader = "3059301306072a8648ce3d020106082a8648ce3d030107034200";
      const pubKeyBytes = parseHexString(pubHeader + pubRaw).input;
      return window.crypto.subtle.importKey(
        "spki",
        pubKeyBytes,
        {
          name: "ECDH",
          namedCurve: "P-256"
        },
        false,
        []
      );
    }

    function performKeyAgreement(prvPem /* KRP */, pubRaw /* device */) {
      return Promise.all([
        getPrivKey(prvPem),
        getPubKey(pubRaw)
      ])
      .then(function (keys) {
        const prv = keys[0];
        const pub = keys[1];
        return deriveEcdh(prv, pub);
      })
      .then(deriveAesKey);
    }

    function deriveEcdh(prv, pub) {
      return window.crypto.subtle.deriveBits(
        {
          name: "ECDH",
          public: pub
        },
        prv,
        256 // need 32 bytes
      ).then(function (z) { return new Uint8Array(z); });
    }

    function deriveAesKey(Z) {
      var otherInfo = new Uint8Array(33);
      otherInfo.set([0x60, 0x85, 0x74, 0x06, 0x08, 0x03, 0x00], 0); // algorithm-id
      otherInfo.set(cipherInfo.origSysTitle, 7);
      otherInfo.set([0x09, 0x04], 7 + 8);
      otherInfo.set(cipherInfo.origCounter, 7 + 8 + 2);
      otherInfo.set(cipherInfo.recipSysTitle, 7 + 8 + 2 + 8);
      return concatKdf(Z, otherInfo);
    }

    function concatKdf(Z, otherInfo) {
      var data = new Uint8Array(4 + Z.byteLength + otherInfo.byteLength);
      data.set([0, 0, 0, 1], 0);
      data.set(Z, 4);
      data.set(otherInfo, 4 + Z.byteLength);
      return window.crypto.subtle.digest("SHA-256", data)
        .then(function (digest) { return new Uint8Array(digest.slice(0, 16)); });
    }

    // Agree a key and pass it to the callback
    performKeyAgreement(prvKey, pubKey)
      .then(function (aesKey) { doneCb(true, aesKey); })
      .catch(function (e) { doneCb(false, e); });
  }

  function parseProtectionParameters(x) {
    var cipherInfo = {};
    putBytes("Protection Parameters", getBytes(x, 4));
    parseDlmsEnum(x, " Protection Type", true, { 2: "Authentication and Encryption" });
    putBytes(" Protection Options", getBytes(x, 2));
    cipherInfo.origCounter = x.input.subarray(x.index + 3, x.index + 11);
    putBytes(" Transaction Id", getBytes(x, 11));
    cipherInfo.origSysTitle = x.input.subarray(x.index + 2, x.index + 10);
    putBytes(" Originator System Title", getBytes(x, 10));
    cipherInfo.recipSysTitle = x.input.subarray(x.index + 2, x.index + 10);
    putBytes(" Recipient System Title", getBytes(x, 10));
    putBytes(" Other Information", getBytes(x, 2));
    putBytes(" Key Info", getBytes(x, 2));
    parseDlmsEnum(x, "  Key Info Type", true, { 2: "Agreed Key" });
    putBytes("  Agreed Key Info Options", getBytes(x, 2));
    putBytes("   Key Parameters", getBytes(x, 3), "C(0e, 2s ECC CDH)");
    putBytes("   Key Ciphered Data", getBytes(x, 2));
    return cipherInfo;
  }

  function parseDlmsProtectedAttributesResponse(x, indent) {
    putBytes("Get Protected Attributes Response", getBytes(x, 2));
    parseDlmsProtectedData(x);
  }

  function parseDlmsProtectedData(x) {
    cipherInfo = parseProtectionParameters(x);
    var lenSz = parseLength(x, 1);
    var len = lenSz.length;
    var off = lenSz.size + 1;
    putBytes("Protected Attributes", getBytes(x, off));
    var y = getBytes(x, len);
    putBytes(" Security Header", getBytes(y, 5));
    var ciphertextAndTag = y.input.subarray(y.index, y.index + len - 5);
    putBytes(" Encrypted DLMS Payload", getBytes(y, len - 5 - 12));
    putBytes(" AE MAC", getBytes(y, 12));

    // TODO: may be better placed at the end of the message, after the MAC
    sensitive = true;
    putSeparator("Decryption inputs");
    putBytes("AES key generation", getBytes(x, 0), '<div id="key-generation"></div>');
    putBytes("AES key", getBytes(x, 0), '<div id="enc-input"></div>');
    sensitive = false;

    const decryptAnchor = "<tr id=\"decrypted-payload\">";
    output += decryptAnchor;

    // TODO: check key agreement and AES decryption instead
    execIfSignatureCheckIsAvailable(function() {
      // When this is executed message has been processed and DOM updated
      var keyGeneration = document.getElementById("key-generation");
      var encInput = document.getElementById("enc-input");
      if (keyGeneration && encInput) {
        // key-generation elements
        var encPubKeyArea = document.createElement("textarea");
        encPubKeyArea.id = "enc-pub-key";
        encPubKeyArea.rows = "3";
        encPubKeyArea.placeholder = "Public key of device (raw hex starting with 04).";
        var encPrvKeyArea = document.createElement("textarea");
        encPrvKeyArea.id = "enc-prv-key";
        encPrvKeyArea.rows = "5";
        encPrvKeyArea.placeholder = "Private key of KRP (PEM).";
        var status = document.createElement("div");
        status.id = "key-generation-status";
        status.innerHTML = "<p> </p>";
        var generateKeyButton = document.createElement("button");
        generateKeyButton.innerText = "Generate key";

        // enc-input elements
        var encAesKeyArea = document.createElement("textarea");
        encAesKeyArea.id = "enc-aes-key";
        encAesKeyArea.rows = "1";
        encAesKeyArea.placeholder = "Paste here AES key to decrypt the message (raw hex).";
        var footer = document.createElement("div");
        footer.innerHTML = "<div>&zwnj;</div>";
        var decryptButton = document.createElement("button");
        decryptButton.innerText = "Decrypt";

        generateKeyButton.onclick = function() {
          const pubKey = document.getElementById("enc-pub-key").value.trim();
          const prvKey = document.getElementById("enc-prv-key").value.trim();
          deriveKeyFromPair(prvKey, pubKey,
            function (ok, aesKey) {
              if (ok) {
                encPubKeyArea.readOnly = true;
                encPrvKeyArea.readOnly = true;
                encAesKeyArea.value = arrayToHex(aesKey);
                generateKeyButton.disabled = true;
                status.innerHTML = '<p style="color: green">Key generation <b>SUCCESS</b></p>';
                encAesKeyArea.readOnly = true;
                // Decrypt!
                decryptButton.click();
              }
              else {
                status.innerHTML = '<p style="color: red">Key generation <b>FAILED</b></p>';
              }
            });
        };

        decryptButton.onclick = function() {
          const key = document.getElementById("enc-aes-key").value.trim();
          var aesKey = parseHexString(key).input;
          decryptPayloadWithKey(ciphertextAndTag, aesKey,
            function (yy) {
              parseDlmsData(yy);
              putUnparsedBytes(yy);
            });
          encAesKeyArea.readOnly = true;
          decryptButton.disabled = true;
          encPubKeyArea.readOnly = true;
          encPrvKeyArea.readOnly = true;
          generateKeyButton.disabled = true;
        };

        keyGeneration.appendChild(encPubKeyArea);
        keyGeneration.appendChild(encPrvKeyArea);
        keyGeneration.appendChild(generateKeyButton);
        keyGeneration.appendChild(status);
        encInput.appendChild(encAesKeyArea);
        encInput.appendChild(decryptButton);
        encInput.appendChild(footer);
      }
    });

  }

  function parseDlmsSequenceOf(x, name, parse) {
    var n = x.input[x.index];
    putBytes(name, getBytes(x, 1));
    for (var i = 0; i < n; i++) {
      parse(x, "[" + i + "] ");
    }
  }

  function parseDlmsData(x, indent) {
    indent = indent || "";
    var choice = x.input[x.index];
    if (choice == 0) {
      putBytes(indent + "Null", getBytes(x, 1));
    } else if (choice == 1) {
      var n = x.input[x.index + 1];
      putBytes(indent + "Array", getBytes(x, 2), n + (n > 1 ? " elements" : " element"));
      for (var i = 0; i < n; i++) {
        parseDlmsData(x, indent + " ");
      }
    } else if (choice == 2) {
      var n = x.input[x.index + 1];
      putBytes(indent + "Structure", getBytes(x, 2));
      for (var i = 0; i < n; i++) {
        parseDlmsData(x, indent + " ");
      }
    } else if (choice == 3) {
      parseDlmsBoolean(x, indent + "Boolean", true);
    } else if (choice == 4) {
      parseDlmsBitString(x, indent + "Bit String", true);
    } else if (choice == 5) {
      parseDlmsDoubleLong(x, indent + "Double Long", true);
    } else if (choice == 6) {
      parseDlmsDoubleLongUnsigned(x, indent + "Double Long Unsigned", true);
    } else if (choice == 9) {
      parseDlmsOctetString(x, indent + "Octet String", true);
    } else if (choice == 10) {
      parseDlmsOctetString(x, indent + "Visible String", true);
    } else if (choice == 15) {
      parseDlmsInteger(x, indent + "Integer", true);
    } else if (choice == 16) {
      parseDlmsLong(x, indent + "Long", true);
    } else if (choice == 17) {
      parseDlmsUnsigned(x, indent + "Unsigned", true);
    } else if (choice == 18) {
      parseDlmsLongUnsigned(x, indent + "Long Unsigned", true);
    } else if (choice == 19) {
      parseDlmsCompactArray(x, indent + "Compact Array", indent);
    } else if (choice == 22) {
      parseDlmsEnum(x, indent + "Enum", true);
    } else {
      throw "TODO: DLMS Data CHOICE " + choice;
    }
  }

  function parseDlmsBitString(x, name, hasTag) {
    var offset = hasTag ? 1 : 0;
    var bitlen = x.input[x.index + offset];
    var bytelen = 1;
    if (bitlen == 0x81) {
      bitlen = parseNumber(x, 1, offset);
      bytelen += 1;
    } else if (bitlen == 0x82) {
      bitlen = parseNumber(x, 2, offset);
      bytelen += 2;
    }
    var value = "";
    var nfull = Math.floor(bitlen / 8);
    var rem = bitlen - nfull * 8;

    function prettybit(index, bit) {
      return tooltip(bit, "Bit #" + index);
    }
    for (var i = 0; i < nfull; i++) {
      // full byte
      var b = x.input[x.index + offset + bytelen + i];
      for (var j = 0; j < 8; j++) {
        value += prettybit(i * 8 + j, (b >> (7 - j)) & 1);
      }
      value += " ";
    }
    if (rem > 0) {
      // partial byte, MSB-aligned
      var b = x.input[x.index + offset + bytelen + nfull];
      for (var j = 0; j < rem; j++) {
        value += prettybit(i * 8 + j, (b >> (7 - j)) & 1);
      }
    }

    bytelen += Math.floor((bitlen + 7) / 8);
    putBytes(name, getBytes(x, offset + bytelen), value);
  }

  function getDlmsDate(x, offset) {
    var year = parseNumber(x, 2, offset);
    var month = x.input[x.index + offset + 2];
    var dayOfMonth = x.input[x.index + offset + 3];
    var dayOfWeek = x.input[x.index + offset + 4];

    //Day
    if (dayOfMonth == 0xFF)
      var hday = "Every day";
    else if (dayOfMonth == 0xFD)
      var hday = "2nd last " + daysInWeek[dayOfWeek] + " of";
    else if (dayOfMonth == 0xFE)
      var hday = "Last " + daysInWeek[dayOfWeek] + " of";
    else if (dayOfMonth > 0 && dayOfMonth < 10)
      var hday = "0" + dayOfMonth;
    else if (dayOfMonth > 0 && dayOfMonth <= 31)
      var hday = dayOfMonth;
    else
      return null;

    //Month
    if (month == 0xFF)
      var hmon = "every month of";
    else if (month == 0xFD)
      var hmon = "DST-end month of";
    else if (month == 0xFE)
      var hmon = "DST-begin month of";
    else if (month >= 1 && month <= 12)
      var hmon = monthsInYear[month];
    else
      return null;

    //Year
    if (year == 0xFFFF)
      var hyear = "every year";
    else
      var hyear = year;

    var date = hday + " " + hmon + " " + hyear;
    return date
  }

  function getDlmsTime(x, offset) {
    var hour = x.input[x.index + offset];
    var mins = x.input[x.index + offset + 1];
    var sec  = x.input[x.index + offset + 2];
    var hsec = x.input[x.index + offset + 3];

    if (hour == 0xFF)
      hour = "Every hour";
    else if (hour < 10)
      hour = "0" + hour;
    else if (hour > 23)
      return null;

    if (mins == 0xFF)
      mins = "Every minute";
    else if (mins < 10)
      mins = "0" + mins;
    else if (mins > 59)
      return null;

    if (sec == 0xFF)
      sec = "Every second";
    else if (sec < 10)
      sec = "0" + sec;
    else if (sec > 59)
      return null;

    if (hsec == 0xFF)
      hsec = "00";
    else if (hsec < 10)
      hsec = "0" + hsec;

    var time = hour + ":" + mins + ":" + sec + "." + hsec;
    return time
  }

  function getDlmsLongDate(x, offset) {
    function checkSameValue(arr, val) {
      for (var i = 0; i < arr.length; i++) {
        if (arr[i] != val) return false;
      }
      return true;
    }

    var dev = parseNumber(x, 2, offset + 9);
    var clk = x.input[x.index + offset + 11];
    if (dev == 0x8000 && clk == 0xFF) {
      var dateTimeSlice = x.input.subarray(x.index + offset, x.index + offset + 9);
      if (checkSameValue(dateTimeSlice, 0x00)) {
        // for DLMS COSEM Commands Payloads, activation date-time(s) have the value 0x0000000000000000008000FF;
        return "NOW";
      }
      else if (checkSameValue(dateTimeSlice, 0xFF)) {
        // for DLMS COSEM Commands Payloads, activation date-time(s) have the value 0xFFFFFFFFFFFFFFFFFF8000FF;
        return "NEVER";
      }
    }

    var date = getDlmsDate(x, offset);
    var time = getDlmsTime(x, offset + 5);
    if (date && time)
      date += " " + time;
    return date
  }

  function getDlmsObis(x, offset) {
    x.index += offset;
    text = formatObis(x);
    x.index -= offset;
    return text;
  }

  function parseDlmsOctetString(x, name, hasTag) {
    var offset = hasTag ? 1 : 0;
    var lenSz = parseLength(x, offset);
    var len = lenSz.length;
    var stringLike = true;
    for (var i = 0; i < len; i++) {
      var c = x.input[x.index + offset + lenSz.size + i];
      if (c < 0x20 || c > 0x7E) {
        stringLike = false;
        break;
      }
    }
    var text = "";
    if (len > 1 && stringLike) {
      for (var i = 0; i < len; i++) {
        text += String.fromCharCode(x.input[x.index + offset + lenSz.size + i]);
      }
      text = '"' + escapeHtml(text) + '"';
    } else if (len == 4) {
      text = getDlmsTime(x, offset + 1);
    } else if (len == 5) {
      text = getDlmsDate(x, offset + 1);
    } else if (len == 12) {
      text = getDlmsLongDate(x, offset + 1);
    } else if (len == 6) {
      text = getDlmsObis(x, offset + 1);
    }
    putBytes(name, getBytes(x, offset + lenSz.size + len), text);
  }

  function parseNumber(x, size, offset) {
    // XXX Max safe integer in JavaScript is 2^53-1, can't handle size > 6
    offset = offset || 0;
    var value = 0;
    for (var i = 0; i < size; i++) {
      value *= 0x100;
      value += x.input[x.index + offset + i];
    }
    return value;
  }

  function parseNumberLE(x, size, offset) {
    // XXX Max safe integer in JavaScript is 2^53-1, can't handle size > 6
    offset = offset || 0;
    var value = 0;
    for (var i = size; i > 0; i--) {
      value *= 0x100;
      value += x.input[x.index + offset + i - 1];
    }
    return value;
  }

  function parseLength(x, offset) {
    offset = offset || 0;
    var len = x.input[x.index + offset];
    var size = 1;
    if (len & 0x80) {
      // Multi-byte length, limit to 3 bytes
      size += len & 3;
      len = parseNumber(x, len & 3, offset + 1);
    }
    return { length: len, size: size };
  }

  function parseDlmsBoolean(x, name, hasTag) {
    var offset = hasTag ? 1 : 0;
    var value = x.input[x.index + offset] ? "True" : "False";
    putBytes(name, getBytes(x, offset + 1), value);
  }

  function parseDlmsNumber(x, name, size, hasTag, hasSign) {
    var offset = hasTag ? 1 : 0;
    var value = parseNumber(x, size, offset);
    if (hasSign && value > Math.abs(1 << (size * 8 - 1)) - 1) {
      value -= 1 << (size * 8);
    }
    value = tooltip(value, toHex(value, size * 8));
    putBytes(name, getBytes(x, offset + size), value);
  }

  function parseDlmsInteger(x, name, hasTag) {
    parseDlmsNumber(x, name, 1, hasTag, true);
  }

  function parseDlmsUnsigned(x, name, hasTag) {
    parseDlmsNumber(x, name, 1, hasTag, false);
  }

  function parseDlmsLong(x, name, hasTag) {
    parseDlmsNumber(x, name, 2, hasTag, true);
  }

  function parseDlmsLongUnsigned(x, name, hasTag) {
    parseDlmsNumber(x, name, 2, hasTag, false);
  }

  function parseDlmsDoubleLong(x, name, hasTag) {
    parseDlmsNumber(x, name, 4, hasTag, true);
  }

  function parseDlmsDoubleLongUnsigned(x, name, hasTag) {
    parseDlmsNumber(x, name, 4, hasTag, false);
  }

  function parseDlmsEnum(x, name, hasTag, values) {
    var offset = hasTag ? 1 : 0;
    var value = parseNumber(x, 1, offset);
    var notes = values && values[value] || value;
    putBytes(name, getBytes(x, offset + 1), notes);
  }

  function parseDlmsAlertCode(x) {
    var alertCode = parseNumber(x, 2, 1);
    putBytes("Alert Code", getBytes(x, 3), getAlertCodeName(alertCode));
  }

  function parseDlmsCompactArray(x, name, indent) {
    indent = indent || "";
    putBytes(name, getBytes(x, 1));
    putBytes(indent + " Type Description", getBytes(x, 0));
    var typeDescription = parseDlmsTypeDescription(x, indent + "  ");
    parseDlmsCompactArrayContents(indent + " ", x, typeDescription);
  }

  function parseDlmsTypeDescription(x, indent) {
    var choice = x.input[x.index];
    var typeDescription = { choice: choice, children: null };
    if (choice == 1) {  // array
      var numberOfElements = parseNumber(x, 2, 1);
      putBytes(indent + "Array of " + numberOfElements, getBytes(x, 3));
      var t = parseDlmsTypeDescription(x, indent + " ");
      typeDescription.children = { number: numberOfElements, type: t };
    } else if (choice == 2) {  // structure
      var n = x.input[x.index + 1];
      putBytes(indent + "Structure", getBytes(x, 2));
      typeDescription.children = [];
      for (var i = 0; i < n; i++) {
        var t = parseDlmsTypeDescription(x, indent + " ");
        typeDescription.children.push(t);
      }
    } else if (choice == 3) { // boolean
      putBytes(indent + "Boolean", getBytes(x, 1));
    } else if (choice == 4) { // bit-string
      putBytes(indent + "Bit-String", getBytes(x, 1));
    } else if (choice == 5) { // double-long
      putBytes(indent + "Double Long", getBytes(x, 1));
    } else if (choice == 6) { // double-long-unsigned
      putBytes(indent + "Double Long Unsigned", getBytes(x, 1));
    } else if (choice == 9) { // octet-string
      putBytes(indent + "Octet String", getBytes(x, 1));
    } else if (choice == 10) { // visible-string
      putBytes(indent + "Visible String", getBytes(x, 1));
    } else if (choice == 15) { // integer
      putBytes(indent + "Integer", getBytes(x, 1));
    } else if (choice == 16) { // long
      putBytes(indent + "Long", getBytes(x, 1));
    } else if (choice == 17) { // unsigned
      putBytes(indent + "Unsigned", getBytes(x, 1));
    } else if (choice == 18) { // long-unsigned
      putBytes(indent + "Long Unsigned", getBytes(x, 1));
    } else if (choice == 22) { // enum
      putBytes(indent + "Enum", getBytes(x, 1));
    } else {
      putBytes(indent + "Unknown", getBytes(x, 1), "TODO");
    }
    return typeDescription;
  }

  function parseDlmsCompactArrayContents(indent, x, typeDescription) {
    var arrayContentsLen = x.input[x.index];
    var bytes = 1;
    if (arrayContentsLen == 0x81) {
      arrayContentsLen = parseNumber(x, 1, 1);
      bytes = 2;
    } else if (arrayContentsLen == 0x82) {
      arrayContentsLen = parseNumber(x, 2, 1);
      bytes = 3;
    }
    putBytes(indent + "Contents", getBytes(x, bytes));
    var contents = getBytes(x, arrayContentsLen);
    var index = 0;
    while (contents.index < contents.end) {
      // put each element of the array according to the type description
      parseDlmsTypeDescriptionContentsData(indent + "[" + index + "] ", contents, typeDescription);
      index++;
    }
  }

  function parseDlmsTypeDescriptionContentsData(indent, x, typeDescription) {
    var choice = typeDescription.choice;
      if (choice == 1) { // array
        var n = typeDescription.children.number;
        var t = typeDescription.children.type;
        putBytes(indent + "Array", getBytes(x, 0), n + " elements")
        for (var i = 0; i < n; i++) {
          parseDlmsTypeDescriptionContentsData(indent + " ", x, t);
        }
      } else if (choice == 2) { // structure
        var n = typeDescription.children.length;
        putBytes(indent + "Structure", getBytes(x, 0))
        for (var i = 0; i < n; i++) {
          var t = typeDescription.children[i];
          parseDlmsTypeDescriptionContentsData(indent + " ", x, t);
        }
      } else if (choice == 3) { // boolean
        parseDlmsBoolean(x, indent + "Boolean", false);
      } else if (choice == 4) { // bit-string
        parseDlmsBitString(x, indent + "Bit String", false);
      } else if (choice == 5) { // double-long
        parseDlmsDoubleLong(indent + "Double Long", false);
      } else if (choice == 6) { // double-long-unsigned
        parseDlmsDoubleLongUnsigned(x, indent + "Double Long Unsigned", false);
      } else if (choice == 9) { // octet-string
        parseDlmsOctetString(x, indent + "Octet String", false);
      } else if (choice == 10) { // visible-string
        parseDlmsOctetString(x, indent + "Visible String", false);
      } else if (choice == 15) { // integer
        parseDlmsInteger(x, indent + "Integer", false);
      } else if (choice == 16) { // long
        parseDlmsLong(indent + "Long", false);
      } else if (choice == 17) { // unsigned
        parseDlmsUnsigned(x, indent + "Unsigned", false);
      } else if (choice == 18) { // long-unsigned
        parseDlmsLongUnsigned(x, indent + "Long Unsigned", false);
      } else if (choice == 22) { // enum
        parseDlmsEnum(x, indent + "Enum", false);
      } else {
        throw "TODO: DLMS Data CHOICE (compact array)" + choice;
      }
  }

  function parseDlmsCosemAttributeDescriptor(x) {
    var cosemClass = parseDlmsCosemClassId(x);
    parseDlmsCosemInstanceId(x, cosemClass);
    parseDlmsCosemAttributeId(x, cosemClass);
  }

  function parseDlmsCosemMethodDescriptor(x) {
    var cosemClass = parseDlmsCosemClassId(x);
    parseDlmsCosemInstanceId(x, cosemClass);
    parseDlmsCosemMethodId(x, cosemClass);
  }

  function parseDlmsCosemClassId(x) {
    // The attributes arrays start with attribute 2 (attribute 1 is always "logical_name").
    // The methods arrays start with method 1.
    var classes = {
      0x0001: {
        name: "Data",
        attributes: [ "Value" ],
        methods: [],
        instances: {
          0x00005E2C0301: "Disable Privacy PIN Protection",
          0x00005E2C0302: "Restrict Data Date Time",
          0x00005E2C0A00: "Sub GHz Configuration Settinâ€‹gs",
          0x00005E2C0A01: "CHF Sub GHz Channel Scan",
          0x00005E2C0A02: "Operating Sub GHz Channel",
          0x00005E2C2214: "Power Import Collection",
          0x0002600D01FF: "Supplier Message",
        },
      },
      0x0003: {
        name: "Register",
        attributes: [ "Value", "Scaler Unit" ],
        methods: [],
        instances: {
          0x0100020800FF: "Active Export Register",
          0x0100040800FF: "Reactive Export Register",
        },
      },
      0x0007: {
        name: "Profile Generic",
        attributes: [],
        methods: [ "Reset" ],
        instances: {
          0x0000636200FF: "Event Log (inc GPF)",
          0x0011636202FF: "Auxiliary Load Control Switcâ€‹h Event Log",
        },
      },
      0x0009: {
        name: "Script Table",
        attributes: [],
        methods: [ "Execute" ],
        instances: { 0x00000A0064FF: "Tariff Blockâ€‹ â€‹Counter Matrix TOUâ€‹" },
      },
      0x000A: {
        name: "Schedule",
        attributes: [ "Entries" ],
        methods: [],
        instances: { 0x00010C0001FF: "Non-Disablement Calendar" },
      },
      0x000B: {
        name: "Special Days Table",
        attributes: [ "Entries" ],
        methods: [],
        instances: {
          0x00010B0000FF: "Tariff Switching Tableâ€‹ Special Days",
          0x00010B0001FF: "Tariff Switching Tableâ€‹ Secondary Element Special Days",
          0x00010B0002FF: "Non-Disablement Calendarâ€‹ Special Days",
        },
      },
      0x0014: {
        name: "Activity Calendar",
        attributes: [
          "Calendar Name Active",
          "Season Profile Active",
          "Week Profile Table Active",
          "Day Profile Table Active",
          "Calendar Name Passive",
          "Season Profile Passive",
          "Week Profile Table Passive",
          "Day Profile Table Passive",
          "Activate Passive Calendar Time",
        ],
        methods: [],
        instances: {
          0x00000D0000FF: "Tariff Switching Table",
          0x00000D0001FF: "Tariff Switching Tableâ€‹ Secondary Element",
        },
      },
      0x0015: {
        name: "Register Monitor",
        attributes: [ "Thresholds" ],
        methods: [],
        instances: {
          0x000010010BFF: "Tariff Threshold Matrix Blocâ€‹ks â€‹TOU1",
          0x000010010CFF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU2",
          0x000010010DFF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU3",
          0x000010010EFF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU4",
          0x000010010FFF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU5",
          0x0000100110FF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU6",
          0x0000100111FF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU7",
          0x0000100112FF: "â€‹â€‹Tariff Threshold Matrix Blocâ€‹ks â€‹TOU8",
        },
      },
      0x001E: {
        name: "Data Protection",
        attributes: [],
        methods: [ "Get Protected Attributes" ],
        instances: {
          0x00002B0208FF: "Import Register Collection",
          0x00002B0209FF: "Tariff TOU Register Collectiâ€‹on",
          0x00002B020AFF: "Tariff Block TOU Register Colâ€‹lection",
        },
      },
      0x0068: {
        name: "ZigBee Network Control",
        attributes: [
          "Enable Disable Joining",
          "Join Timeout",
          "Active Devices",
        ],
        methods: [
          "Register Device",
          "Unregister Device",
          "Unregister All Devices",
          "Backup PAN",
          "Restore PAN",
        ],
        instances: { 0x00001E0300FF: "Device Log (CHF)" },
      },
      0x006F: {
        name: "Account",
        attributes: [
          "Account Mode and Status",
          "Current Credit in Use",
          "Current Credit Status",
          "Available Credit",
          "Amount to Clear",
          "Clearance Threshold",
          "Aggregated Debt",
          "Credit Reference List",
          "Charge Reference List",
          "Credit Charge Configuration",
          "Token Gateway Configuration",
          "Account Activation Time",
        ],
        methods: [],
        instances: { 0x0001130000FF: "SuspendDebtDisabled / SuspendDebtEmergency / Payment Mode" },
      },
      0x0070: {
        name: "Credit",
        attributes: [],
        methods: [
          "Update Amount",
          "Set Amount to Value",
          "Invoke Credit",
        ],
        instances: {
          0x0000130A00FF: "Meter Balance",
          0x0000130A01FF: "Emergency Credit Balance",
          0x0000130A02FF: "Accumulated Debt Register",
        },
      },
      0x0071: {
        name: "Charge",
        attributes: [
          "Total Amount Paid",
          "Charge Type",
          "Priority",
          "Unit Charge Active",
          "Unit Charge Passive",
          "Unit Charge Activation Time",
          "Period",
          "Charge Configuration",
          "Last Collection Time",
          "Last Collection Amount",
          "Total Amount Remaining",
          "Proportion",
        ],
        methods: [
          "Update Unit Charge",
          "Activate Passive Unit Charge",
          "Collect",
          "Update Total Amount Remaining",
        ],
        instances: {
          0x0000131400FF: "Tariff Block Price Matrix TOU",
          0x0000131401FF: "Debt Recovery Rates 1",
          0x0000131402FF: "Debt Recovery Rates 2",
          0x0000131403FF: "Debt Recovery per Paymentâ€‹",
          0x0000131404FF: "Standing Charge",
          0x0000131405FF: "Secondary Tariff TOU Price Maâ€‹trix",
        },
      },
      0x0073: {
        name: "Token Gateway",
        attributes: [],
        methods: [ "Enter" ],
        instances: { 0x0000132800FF: "Prepayment Credit" },
      },
      0x2328: {
        name: "GBCS Extended Data",
        attributes: [
          "Value Active",
          "Scaler Unit Active",
          "Value Passive",
          "Scaler Unit Passive",
          "Activate Passive Value Time",
        ],
        methods: [],
        instances: {
          0x00003F0101FF: "Tariff Threshold Matrix",
          0x00005E2C0200: "Currency Unit",
          0x00005E2C020A: "Prepayment Credit Max Credit Threshold",
          0x00005E2C0214: "Prepayment Creditâ€‹ Max Meter Balance",
          0x00005E2C8003: "Emergency Credit Threshold",
          0x00005E2C8009: "Low Credit Thresholdâ€‹",
          0x00005E2C800C: "Debt Recovery Rate Capâ€‹ Amount",
          0x00005E2C8002: "Emergency Credit Limit",
          0x00005E2C800D: "Debt Recovery Rate Capâ€‹ Period",
          0x00005E2C8016: "Disablement Threshold Meter Balance",
          0x00005E2C801C: "Non-Disablement Calendar",
          0x00005E2C801D: "Tariff Switching Tableâ€‹ Special Days",
          0x00005E2C801E: "Tariff Switching Tableâ€‹ Secondary Element Special Days",
          0x00005E2C801F: "Non-Disablement Calendar Special Days",
          0x0000600D00FF: "Contact Detailsâ€‹ Supplier Telephone Numbeâ€‹r",
          0x0000600D01FF: "Contact Detailsâ€‹ Supplier Name",
        },
      },
    };
    var id = parseNumber(x, 2);
    var cosemClass = classes[id] || { name:"IC " + id, attributes:[], methods:[], instances:{} };
    putBytes("â”Œ Class Id", getBytes(x, 2), "â”Œ " + cosemClass.name);
    return cosemClass;
  }

  function formatObis(x) {
    return x.input[x.index] + "-" + x.input[x.index + 1]
      + ":" + x.input[x.index + 2] + "." + x.input[x.index + 3]
      + "." + x.input[x.index + 4] + "." + x.input[x.index + 5];
  }

  function parseDlmsCosemInstanceId(x, cosemClass) {
    var id = parseNumber(x, 6);
    var cosemInstance = cosemClass.instances[id];
    var name = formatObis(x)
    if (cosemInstance != undefined)
      name = name + " - " + cosemInstance;
    putBytes("â”œ Instance Id", getBytes(x, 6), "â”œ " + name);
  }

  function parseDlmsCosemAttributeId(x, cosemClass) {
    var id = x.input[x.index];
    var name = cosemClass.attributes[id - 2] || "Attribute " + id;
    putBytes("â”” Attribute Id", getBytes(x, 1), "â”” " + name);
  }

  function parseDlmsCosemMethodId(x, cosemClass) {
    var id = x.input[x.index];
    var name = cosemClass.methods[id - 1] || "Method " + id;
    putBytes("â”” Method Id", getBytes(x, 1), "â”” " + name);
  }

  function parseDlmsSelectiveAccessDescriptor(x) {
    putBytes("Access Selector", getBytes(x, 1));
    parseDlmsData(x);
  }

  function parseDlmsDataAccessResult(x) {
    var values = {
      0: "Success",
      1: "Hardware Fault",
      2: "Temporary Failure",
      3: "Read Write Denied",
      4: "Object Undefined",
      9: "Object Class Inconsistent",
      11: "Objext Unavailable",
      12: "Type Unmatched",
      13: "Scope of Access Violated",
      14: "Data Block Unavailable",
      15: "Long Get Aborted",
      16: "No Long Get in Progress",
      17: "Long Set Aborted",
      18: "No Long Set in Progress",
      19: "Data Block Number Invalid",
      250: "Other Reason",
    };
    var value = x.input[x.index];
    putBytes("Data Access Result", getBytes(x, 1), values[value] || "");
  }

  function parseDlmsActionResult(x) {
    var values = {
      0: "Success",
      1: "Hardware Fault",
      2: "Temporary Failure",
      3: "Read Write Denied",
      4: "Object Undefined",
      9: "Object Class Inconsistent",
      11: "Object Unavailable",
      12: "Type Unmatched",
      13: "Scope of Access Violated",
      14: "Data Block Unavailable",
      15: "Long Action Aborted",
      16: "No Long Action in Progress",
      250: "Other Reason",
    };
    var value = x.input[x.index];
    putBytes("Action Result", getBytes(x, 1), values[value] || "");
  }

  // GBZ Payloads

  function parseGbzPayload(x){
    putBytes("Profile ID", getBytes(x, 2));
    var numberOfGbzComponents = x.input[x.index];
    putBytes("Number of GBZ components", getBytes(x, 1), numberOfGbzComponents);
    for (var i = 1; i <= numberOfGbzComponents; i++) {
      putSeparator("GBZ Component " + i);
      parseGbzComponent(x);
    }
  }

  function parseGbzAlertPayload(x){
    putBytes("Profile ID", getBytes(x, 2));
    putBytes("Number of GBZ components", getBytes(x, 1));
    parseGbzAlertCode(x);
    parseGbzTime(x, "Time Stamp");
    if (x.index < x.end) {
      putBytes("GBZ Use Case Specific Components", x);
    }
  }

  function parseGbzFutureDatedAlertPayload(x) {
    putBytes("Profile ID", getBytes(x, 2));
    putBytes("Number of GBZ components", getBytes(x, 1));
    parseGbzAlertCode(x);
    parseGbzTime(x, "Time Stamp");
    putBytes("Future Dated Alert Payload", getBytes(x, 1));
    parseMessageCode("Message Code", x);
    parseCounter("Originator Counter", x);
    var cluster = parseClusterId(x);
    var frameControl = x.input[x.index];
    putBytes("Frame Control", getBytes(x, 1));
    parseCommandId(x, frameControl, cluster);
  }

  function parseGbzFirmwareDistributionReceiptAlert(x) {
    putBytes("Profile ID", getBytes(x, 2));
    putBytes("Number of GBZ components", getBytes(x, 1));
    parseGbzAlertCode(x);
    parseGbzTime(x, "Time Stamp");
    parseDlmsOctetString(x, "Calculated Manufacturer Hash", true);
  }

  function parseGbzGcs53AlertPayload(x) {
    putBytes("Profile ID", getBytes(x, 2));
    putBytes("Number of GBZ components", getBytes(x, 1));
    parseGbzAlertCode(x);
    parseGbzTime(x, "Time Stamp");
    parseGbzComponent(x);
  }

  function arrayToHex(arr) {
    var ret = "";
    for (var i = 0; i < arr.length; i++) {
        var str = arr[i].toString(16);
        z = 2 - str.length + 1;
        str = Array(z).join("0") + str;
        ret += str;
    }
    return ret;
  }

  function getSwappedFrame(name, x) {
    x.input[x.index] ^= 0x02;
    var url = "gbcs-parser.html#" + arrayToHex(x.input);
    x.input[x.index] ^= 0x02;
    return getLink(name, url);
  }

  function parseGbzAlertCode(x) {
    var alertCode = parseNumber(x, 2);
    putBytes("Alert Code", getBytes(x, 2), getAlertCodeName(alertCode));
  }

  function parseGbzComponent(x) {
    var controlField = x.input[x.index];
    if (controlField & 0x02) {
      swapped = getSwappedFrame("(Encryted) Try Decrypted", x)
      putBytes("Control Field", getBytes(x, 1), swapped);
    } else {
      //swapped = getSwappedFrame("(Decrypted) Go encrypted", x)
      putBytes("Control Field", getBytes(x, 1));
    }
    var cluster = parseClusterId(x);
    // Extended Header GBZ Command Length
    var extendedLen = parseNumber(x, 2);
    putBytes("Length", getBytes(x, 2), extendedLen);
    var y = getBytes(x, extendedLen);
    try {
      if (controlField & 0x02) {  // encrypted content
        putBytes("Additional Header", getBytes(y, 2));
      } else if (controlField & 0x10) {
        parseGbzTime(y, "From Date Time");
      }
      // ZCL Header
      var frameControl = y.input[y.index];
      putBytes("Frame Control", getBytes(y, 1));
      putBytes("Sequence Number", getBytes(y, 1));
      var command = parseCommandId(y, frameControl, cluster);
      if (controlField & 0x02) {  // encrypted payload
        var len = parseNumber(y, 2);
        putBytes("Ciphered Information Length", getBytes(y, 2), len);
        putBytes("Security Header", getBytes(y, 5));
        putBytes("Encrypted ZCL Payload", getBytes(y, len - 5 - 12));
        putBytes("AE MAC", getBytes(y, 12));
      } else {  // plaintext payload
        if (command && command.parse) {
          command.parse(y, cluster, frameControl);
        } else {
          putBytes("ZCL Payload", y);
        }
        putUnparsedBytes(y);
      }
    } catch(error) {
      putBytes("ERROR", y, error);
    }
  }

  function parseClusterId(x) {
    var clusters = {
      0x0000: {
        name: "Basic",
        attributes: {
          0x0003: "HW Version",
          0x0004: "Manufacturer Name",
          0x0005: "Model Identifier",
        },
        commands: {},
        responses: {},
      },
      0x0700: {
        name: "Price",
        attributes: {
          0x0100: "Block 1 Threshold",
          0x0101: "Block 2 Threshold",
          0x0102: "Block 3 Threshold",
          0x0202: "Threshold Multiplier",
          0x0203: "Threshold Divisor",
          0x0301: "Standing Charge",
          0x0302: "Conversion Factor",
          0x0303: "Conversion Factor Trailing Digit",
          0x0304: "Calorific Value",
          0x0305: "Calorific Value Unit",
          0x0306: "Calorific Value Trailing Digit",
          0x0400: "No Tier Block 1 Price",
          0x0401: "No Tier Block 2 Price",
          0x0402: "No Tier Block 3 Price",
          0x0403: "No Tier Block 4 Price",
          0x0410: "Tier 1 Block 1 Price",
          0x0420: "Tier 2 Block 1 Price",
          0x0430: "Tier 3 Block 1 Price",
          0x0440: "Tier 4 Block 1 Price",
          0x0615: "Unit of Measure",
          0x0616: "Currency",
          0x0617: "Price Trailing Digits",
        },
        commands: {
          0: [ "Get Current Price", parseZseGetCurrentPrice ],
          11: [ "Get Billing Period", parseZseGetBillingPeriod ],
        },
        responses: {
          0: [ "Publish Price", parseZsePublishPrice ],
          1: [ "Publish Block Period", parseZsePublishBlockPeriod ],
          2: [ "Publish Conversion Factor", parseZsePublishConversionFactor ],
          3: [ "Publish Calorific Value", parseZsePublishCalorificValue ],
          4: [ "Publish Tariff Information", parseZsePublishTariffInformation ],
          5: [ "Publish Price Matrix", parseZsePublishPriceMatrix ],
          6: [ "Publish Block Thresholds", parseZsePublishBlockThresholds ],
          9: [ "Publish Billing Period", parseZsePublishBillingPeriod ],
        },
      },
      0x0702: {
        name: "Metering",
        attributes: {
          0x0000: "Current Summation Delivered",
          0x0014: "Supply Status",
          0x0100: "Current Tier 1 Summation Delivered",
          0x0102: "Current Tier 2 Summation Delivered",
          0x0104: "Current Tier 3 Summation Delivered",
          0x0106: "Current Tier 4 Summation Delivered",
          0x0205: "Remaining Battery Life in Days",
          0x0206: "Current Meter Id",
          0x0300: "Unit of Measure",
          0x0301: "Multiplier",
          0x0302: "Divisor",
          0x0307: "Site ID",
          0x0607: "Supply Tamper State",
          0x0608: "SupplyDepletionState",
          0x0700: "Current no Tier Block 1 Summation Delivered",
          0x0701: "Current no Tier Block 2 Summation Delivered",
          0x0702: "Current no Tier Block 3 Summation Delivered",
          0x0703: "Current no Tier Block 4 Summation Delivered",
          0x0A00: "Bill to Date Delivered",
          0x0B10: "Uncontrolled Flow Threshold",
          0x0B11: "Uncontrolled Flow Threshold Unit of Measure",
          0x0B12: "Uncontrolled Flow Multiplier",
          0x0B13: "Uncontrolled Flow Divisor",
          0x0B14: "Flow Stabilisation Period",
          0x0B15: "Flow Measurement Period",
        },
        commands: {
          6: [ "Get Snapshot", parseZseGetSnapshot ],
          7: [ "Start Sampling", parseZseStartSampling ],
          8: [ "Get Sampled Data", parseZseGetSampledData ],
          11: [ "Change Supply", parseZseChangeSupply ],
          13: [ "Set Supply Status", parseZseSetSupplyStatus ],
          14: [ "Set Uncontrolled Flow Threshold", parseZseSetUncontrolledFlowThreshold ],
        },
        responses: {
          6: [ "Publish Snapshot", parseZsePublishSnapshot ],
          7: [ "Get Sampled Data Response", parseZseGetSampledDataResponse ],
          12: [ "Supply Status Response", parseZseSupplyStatusResponse ],
          13: [ "Start Sampling Response", parseZseStartSamplingResponse ],
        },
      },
      0x0703: {
        name: "Messaging",
        attributes: {},
        commands: {},
        responses: {
          0: [ "Display Message", paseZseDisplayMessage ],
        },
      },
      0x0705: {
        name: "Prepayment",
        attributes: {
          0x0000: "Payment Control Configuration",
          0x0001: "Credit Remaining",
          0x0002: "Emergency Credit Remaining",
          0x0005: "Accumulated Debt",
          0x0006: "Overall Debt Cap",
          0x0010: "Emergency Credit Limit",
          0x0011: "Emergency Credit Threshold",
          0x0021: "Max Credit Limit",
          0x0022: "Max Credit Per Top Up",
          0x0031: "Low Credit Warning Level",
          0x0040: "Cut Off Value",
          0x0211: "Debt Amount 1 (Time-Based Debt 1)",
          0x0216: "Debt Recovery Frequency 1",
          0x0217: "Debt Recovery Amount 1",
          0x0221: "Debt Amount 2 (Time-Based Debt 2)",
          0x0226: "Debt Recovery Frequency 2",
          0x0227: "Debt Recovery Amount 2",
          0x0231: "Debt Amount 3 (Payment-Based Debt)",
          0x0239: "Debt Recovery Top Up Percentage 3",
        },
        commands: {
          0: [ "Select Available Emergency Credit", parseZseSelectAvailableEmergencyCredit ],
          2: [ "Change Debt", parseZseChangeDebt ],
          3: [ "Emergency Credit Setup", parseZseEmergencyCreditSetup ],
          4: [ "Consumer Top Up", parseZseConsumerTopUp ],
          5: [ "Credit Adjustment", parseZseCreditAdjustment ],
          6: [ "Change Payment Mode", parseZseChangePaymentMode ],
          7: [ "Get Prepay Snapshot", parseZseGetPrepaySnapshot ],
          8: [ "Get Top Up Log", parseZseGetTopUpLog ],
          9: [ "Set Low Credit Warning Level", parseZseSetLowCreditWarningLevel ],
          10: [ "Get Debt Repayment Log", parseZseGetDebtRepaymentLog ],
          11: [ "Set Maximum Credit Limit", parseZseSetMaximumCreditLimit ],
          12: [ "Set Overall Debt Cap", parseZseSetOverallDebtCap ],
        },
        responses: {
          1: [ "Publish Prepay Snapshot" ],  // encrypted payload
          2: [ "Change Payment Mode Response", parseZseChangePaymentModeResponse ],
          3: [ "Consumer Top Up Response", parseZseConsumerTopUpResponse ],
          5: [ "Publish Top Up Log", parseZsePublishTopUpLog ],
          6: [ "Publish Debt Log", parseZsePublishDebtLog ],
        },
      },
      0x0707: {
        name: "Calendar",
        attributes: {},
        commands: {
          1: [ "Get Day Profiles", parseZseGetDayProfiles ],
          2: [ "Get Week Profiles", parseZseGetWeekProfiles ],
          3: [ "Get Seasons", parseZseGetSeasons ],
          4: [ "Get Special Days", parseZseGetSpecialDays ],
        },
        responses: {
          0: [ "Publish Calendar", parseZsePublishCalendar ],
          1: [ "Publish Day Profile", parseZsePublishDayProfile ],
          2: [ "Publish Week Profile", parseZsePublishWeekProfile ],
          3: [ "Publish Seasons", parseZsePublishSeasons ],
          4: [ "Publish Special Days", parseZsePublishSpecialDays ],
        },
      },
      0x0708: {
        name: "Device Management",
        attributes: {},
        commands: {
          4: [ "Report Event Configuration", parseZseReportEventConfiguration ],
        },
        responses: {
          0: [ "Publish Change of Tenancy", parseZsePublishChangeOfTenancy ],
          1: [ "Publish Change of Supplier", parseZsePublishChangeOfSupplier ],
          2: [ "Request New Password Response", parseZseRequestNewPasswordResponse ],
          3: [ "Update Site Id", parseZseUpdateSiteId ],
          4: [ "Set Event Configuration", parseZseSetEventConfiguration ],
          5: [ "Get Event Configuration", parseZseGetEventConfiguration ],
          6: [ "Update CIN", parseZseUpdateCin ],
        },
      },
      0x0709: {
        name: "Events",
        attributes: {},
        commands: {
          0: [ "Get Event Log", parseZseGetEventLog ],
          1: [ "Clear Event Log Request", parseZseClearEventLogRequest ],
        },
        responses: {
          1: [ "Publish Event Log", parseZsePublishEventLog ],
          2: [ "Clear Event Log Response", parseZseClearEventLogResponse ],
        },
      },
    };
    var clusterId = parseNumber(x, 2);
    var cluster = clusters[clusterId] ||  { name: "", attributes: {}, commands: {}, responses: {} };
    putBytes("Cluster Id", getBytes(x, 2), cluster.name);
    return cluster;
  }

  function parseCommandId(x, frameControl, cluster) {
    var command;
    var commandId = x.input[x.index];
    var frameType = frameControl & 3;
    if (frameType == 0) {
      var profileCommands = {
        0: [ "Read Attributes", parseZclReadAttributes ],
        1: [ "Read Attributes Response", parseZclReadAttributesResponse ],
        11: [ "Default Response", parseZclDefaultResponse ],
      };
      command = profileCommands[commandId];
    } else if (frameType == 1) {
      var direction = frameControl & 8;
      if (direction == 0) {
        command = cluster.commands[commandId];
      } else {
        command = cluster.responses[commandId];
      }
    }
    if (command) {
      command = { name: command[0], parse: command[1] };
    }
    var name = (command && command.name) || "";
    putBytes("Command Id", getBytes(x, 1), name);
    return command;
  }

  // ZCL commands

  function parseZclReadAttributes(x, cluster) {
    while (x.index < x.end) {
      var id = parseNumberLE(x, 2);
      var name = cluster.attributes[id] || "";
      putBytes("Attribute Id", getBytes(x, 2), name);
    }
  }

  function parseZclReadAttributesResponse(x, cluster) {
    for (var i = 1; x.index < x.end; i++) {
      putSeparator("Attribute " + i, "attribute");
      var id = parseNumberLE(x, 2);
      var name = cluster.attributes[id] || "";
      putBytes("Attribute Id", getBytes(x, 2), name);
      var status = parseZclStatusCode(x);
      if (status == 0) {
        var typeName = "Attribute Data Type";
        var valueName = "Attribute Data Value";
        var type = x.input[x.index];
        if (type == 0x18) {
          putBytes(typeName, getBytes(x, 1), "BITMAP8");
          parseZclBitmap(8, x, valueName);
        } else if (type == 0x19) {
          putBytes(typeName, getBytes(x, 1), "BITMAP16");
          parseZclBitmap(16, x, valueName);
        } else if (type == 0x20) {
          putBytes(typeName, getBytes(x, 1), "UINT8");
          parseZclUint(8, x, valueName);
        } else if (type == 0x21) {
          putBytes(typeName, getBytes(x, 1), "UINT16");
          parseZclUint(16, x, valueName);
        } else if (type == 0x22) {
          putBytes(typeName, getBytes(x, 1), "UINT24");
          parseZclUint(24, x, valueName);
        } else if (type == 0x23) {
          putBytes(typeName, getBytes(x, 1), "UINT32");
          parseZclUint(32, x, valueName);
        } else if (type == 0x25) {
          putBytes(typeName, getBytes(x, 1), "UINT48");
          parseZclUint(48, x, valueName);
        } else if (type == 0x2B) {
          putBytes(typeName, getBytes(x, 1), "INT32");
          parseZclInt32(x, valueName);
        } else if (type == 0x30) {
          putBytes(typeName, getBytes(x, 1), "ENUM8");
          parseZclEnum(8, x, valueName);
        } else if (type == 0x41) {
          putBytes(typeName, getBytes(x, 1), "Octet String");
          parseZclOctetString(x, valueName);
        } else if (type == 0x42) {
          putBytes(typeName, getBytes(x, 1), "Character String");
          parseZclOctetString(x, valueName);
        } else {
          throw "TODO: Read Attributes Response data type " + type;
        }
      }
    }
  }

  function parseZclDefaultResponse(x, cluster, frameControl) {
    var command;
    var commandId = x.input[x.index];
    var direction = frameControl & 8;
    if (direction == 0) {
      command = cluster.responses[commandId];
    } else {
      command = cluster.commands[commandId];
    }
    var name = (command && command[0]) || "";
    putBytes("Command Id", getBytes(x, 1), name);
    parseZclStatusCode(x);
  }

  // ZSE Price Cluster

  function parseZseGetCurrentPrice(x) {
    parseZclUint(8, x, "Command Options");
  }

  function parseZseGetBillingPeriod(x) {
    parseZclUtcTime(x, "Earliest Start Time");
    parseZclUint(32, x, "Minimum Issuer Event Id");
    parseZclUint(8, x, "Number of Commands");
    parseZclBitmap(8, x, "Tariff Type");
  }

  function parseZsePublishPrice(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclOctetString(x, "Rate Label");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Current Time");
    parseZclEnum(8, x, "Unit of Measure", {0: "kWh"});
    parseZclUint(16, x, "Currency", {826: "GBP", 978: "Euro"});
    parseZclBitmap(8, x, "Price Trailing Digit and Price Tier");
    parseZclBitmap(8, x, "Number of Price Tiers and Register Tier");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(16, x, "Duration in Minutes");
    parseZclUint(32, x, "Price");
    // NOTE: the Response may contain an additional 19 octets after this
    // parameter. Those 19 octets do not contain meaningful information
    // and so, if present, should be ignored by all parties
    if (x.end - x.index == 19) {
      putBytes("Meaningless Information", x);
    }
  }

  function parseZsePublishBlockPeriod(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Block Period Start Time");
    parseZclUint(24, x, "Block Period Duration");
    parseZclBitmap(8, x, "Block Period Control");
    parseZclBitmap(8, x, "Block Period Duration Type");
    parseZclBitmap(8, x, "Tariff Type");
    parseZclEnum(8, x, "Tariff Resolution Period");
  }

  function parseZsePublishConversionFactor(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(32, x, "Conversion Factor");
    parseZclBitmap(8, x, "Conversion Factor Trailing Digit");
  }

  function parseZsePublishCalorificValue(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(32, x, "Calorific Value");
    parseZclEnum(8, x, "Calorific Value Unit");
    parseZclBitmap(8, x, "Calorific Value Trailing Digit");
  }

  function parseZsePublishTariffInformation(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(32, x, "Issuer Tariff Id");
    parseZclUtcTime(x, "Start Time");
    parseZclBitmap(8, x, "Tariff Type / Charging Scheme",
      { 0x00: "TOU Tariff / Delivered Tariff", 0x10: "Block Tariff / Delivered Tariff" });
    parseZclOctetString(x, "Tariff Label");
    parseZclUint(8, x, "Number of Price Tiers in Use");
    parseZclUint(8, x, "Number of Block Thresholds in Use");
    parseZclEnum(8, x, "Unit of Measure", {0: "kWh"});
    parseZclUint(16, x, "Currency", {826: "GBP", 978: "Euro"});
    parseZclBitmap(8, x, "Price Trailing Digit");
    parseZclUint(32, x, "Standing Charge");
    parseZclUint(8, x, "Tier Block Mode");
    parseZclUint(24, x, "Block Threshold Multiplier");
    parseZclUint(24, x, "Block Threshold Divisor");
  }

  function parseZsePublishPriceMatrix(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(32, x, "Issuer Tariff Id");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    parseZclBitmap(8, x, "Subpayload Control", { 0: "Block or Block/TOU", 1: "TOU" });
    for (var i = 1; x.index < x.end; i++) {
      parseZclUint(8, x, "Tier / Block Id " + i);
      parseZclUint(32, x, "Price " + i);
    }
  }

  function parseZsePublishBlockThresholds(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(32, x, "Issuer Tariff Id");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    parseZclBitmap(8, x, "Subpayload Control", { 1: "Block thresholds apply to all TOU tiers / block only charging in operation"});
    var n = parseZclUint(8, x, "Number of Block Thresholds");
    for (var i = 1; i <= n; i++) {
      parseZclUint(48, x, "Block Threshold " + i);
    }
  }

  function parseZsePublishBillingPeriod(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Billing Period Start Time");
    parseZclUint(24, x, "Billing Period Duration");
    parseZclUint(8, x, "Billing Period Duration Type");
    parseZclUint(8, x, "Tariff Type");
  }

  // ZSE Metering Cluster

  function parseZseGetSnapshot(x) {
    parseZclUtcTime(x, "Earliest Start Time");
    parseZclUtcTime(x, "Latest End Time");
    parseZclUint(8, x, "Snapshot Offset");
    parseZclBitmap(32, x, "Snapshot Cause");
  }

  function parseZseStartSampling(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Sampling Time");
    parseZclEnum(8, x, "Sample Type");
    parseZclUint(16, x, "Sample Request Interval");
    parseZclUint(16, x, "Max Number of Samples");
  }

  function parseZseGetSampledData(x) {
    parseZclUint(16, x, "Sample Id");
    parseZclUtcTime(x, "Earliest Sample Time");
    parseZclEnum(8, x, "Sample Type");
    parseZclUint(16, x, "Number of Samples");
  }

  function parseZseChangeSupply(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Request Date Time");
    parseZclUtcTime(x, "Implmentation Date Time");
    parseZclEnum(8, x, "Proposed Supply Status");
    parseZclBitmap(8, x, "Supply Control Bits");
  }

  function parseZseSetSupplyStatus(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclEnum(8, x, "Supply Tamper State");
    parseZclEnum(8, x, "Supply Depletion State");
    parseZclEnum(8, x, "Supply Uncontrolled Flow State");
    parseZclEnum(8, x, "Low Limit Supply State");
  }

  function parseZseSetUncontrolledFlowThreshold(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(16, x, "Uncontrolled Flow Threshold");
    parseZclEnum(8, x, "Unit of Measure", {0: "kWh"});
    parseZclUint(16, x, "Multiplier");
    parseZclUint(16, x, "Divisor");
    parseZclUint(8, x, "Stabilisation Period");
    parseZclUint(16, x, "Measurement Period");
  }

  function parseZsePublishSnapshot(x) {
    parseZclUint(32, x, "Snapshot Id");
    parseZclUtcTime(x, "Snapshot Time");
    parseZclUint(8, x, "Snapshots Found");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    parseZclBitmap(32, x, "Snapshot Cause");
    parseZclEnum(8, x, "Snapshot Payload Type");
    putBytes("Snapshot Subpayload", x);
  }

  function parseZseGetSampledDataResponse(x) {
    parseZclUint(16, x, "Sample Id");
    parseZclUtcTime(x, "Sample Start Time");
    parseZclEnum(8, x, "Sample Type");
    parseZclUint(16, x, "Sample Request Interval");
    var n = parseZclUint(16, x, "Number of Samples");
    for (var i = 1; i <= n; i++) {
      parseZclUint(24, x, "Sample " + i);
    }
  }

  function parseZseSupplyStatusResponse(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Implementation Date Time");
    parseZclEnum(8, x, "Supply Status");
  }

  function parseZseStartSamplingResponse(x) {
    parseZclUint(16, x, "Sample Id");
  }

  // ZSE Messaging Cluster

  function paseZseDisplayMessage(x) {
    parseZclUtcTime(x, "Message Id");
    parseZclBitmap(8, x, "Message Control");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(16, x, "Duration in Minutes");
    parseZclOctetString(x, "Message");
    if (x.index < x.end) {
      parseZclBitmap(8, x, "Extended Message Control");
    }
  }

  // ZSE Prepayment Cluster

  function parseZseSelectAvailableEmergencyCredit(x) {
    parseZclUtcTime(x, "Command Issue Date Time");
    parseZclEnum(8, x, "Originating Device", { 0: "Energy Service Interface"});
  }

  function parseZseChangeDebt(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclOctetString(x, "Debt Label");
    parseZclInt32(x, "Debt Amount");
    parseZclUint(8, x, "Debt Recovery Method", { 0: "Time-based debt", 1: "Payment-based debt" });
    parseZclEnum(8, x, "Debt Amount Type", { 1: "Time-based debt (1) Incremental", 3: "Time-based debt (2) Incremental", 5: "Payment-based debt Incremental" });
    parseZclUint(32, x, "Debt Recovery Start Time");
    parseZclUint(16, x, "Debt Recovery Collection Time");
    parseZclEnum(8, x, "Debt Recovery Frequency", { 0: "Hourly", 1: "Daily" });
    parseZclInt32(x, "Debt Recovery Amount");
    parseZclEnum(16, x, "Debt Recovery Balance Percentage");
  }

  function parseZseEmergencyCreditSetup(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(32, x, "Emergency Credit Limit");
    parseZclUint(32, x, "Emergency Credit Threshold");
  }

  function parseZseConsumerTopUp(x) {
    parseZclUint(8, x, "Originating Device");
    parseZclUtrn(x, "Top Up Code");
  }

  function parseZseCreditAdjustment(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUint(8, x, "Credit Adjustment Type");
    parseZclInt32(x, "Credit Adjustment Value");
  }

  function parseZseChangePaymentMode(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Implementation Date Time");
    parseZclUint(16, x, "Proposed Payment Control Configuration",
      {
        0x0497: "Prepayment mode<br>Suspend Debt Emergency = True<br>Suspend Debt Disabled = True",
        0x0097: "Prepayment mode<br>Suspend Debt Emergency = True<br>Suspend Debt Disabled = False",
        0x0c97: "Prepayment mode<br>Suspend Debt Emergency = False<br>Suspend Debt Disabled = True",
        0x0897: "Prepayment mode<br>Suspend Debt Emergency = False<br>Suspend Debt Disabled = False",
        0x0c94: "Credit mode"
      });
    parseZclInt32(x, "Cut Off Value");
  }

  function parseZseGetPrepaySnapshot(x) {
    parseZclUtcTime(x, "Earliest Start Time");
    parseZclUtcTime(x, "Latest End Time");
    parseZclUint(8, x, "Snapshot Offset");
    parseZclBitmap(32, x, "Snapshot Cause", { 1: "General" });
  }

  function parseZseGetTopUpLog(x) {
    parseZclUtcTime(x, "Latest End Time");
    parseZclUint(8, x, "Number of Records");
  }

  function parseZseSetLowCreditWarningLevel(x) {
    parseZclUint(32, x, "Low Credit Warning Level");
  }

  function parseZseGetDebtRepaymentLog(x) {
    parseZclUtcTime(x, "Latest End Time");
    parseZclUint(8, x, "Number of Debts");
    parseZclEnum(8, x, "Debt Type");
  }

  function parseZseSetMaximumCreditLimit(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Implementation Date Time");
    parseZclUint(32, x, "Maximum Credit Level");
    parseZclUint(32, x, "Maximum Credit Per Top Up");
  }

  function parseZseSetOverallDebtCap(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Implementation Date Time");
    parseZclInt32(x, "Overall Debt Cap");
  }

  function parseZseChangePaymentModeResponse(x) {
    parseZclUint(8, x, "Friendly Credit");
    parseZclUint(32, x, "Friendly Credit Calendar ID");
    parseZclUint(32, x, "Emergency Credit Limit");
    parseZclUint(32, x, "Emergency Credit Threshold");
  }

  function parseZseConsumerTopUpResponse(x) {
    parseZclUint(8, x, "Result Type");
    parseZclInt32(x, "Top Up Value");
    parseZclUint(8, x, "Source of Top Up");
    parseZclInt32(x, "Credit Remaining");
  }

  function parseZsePublishTopUpLog(x) {
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    for (var i = 1; x.index < x.end; i++) {
      parseZclUtrn(x, "Top Up Code " + i);
      parseZclInt32(x, "Top Up Amount " + i);
      parseZclUtcTime(x, "Top Up Time " + i);
    }
  }

  function parseZsePublishDebtLog(x) {
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    for (var i = 1; x.index < x.end; i++) {
      parseZclUtcTime(x, "Collection Time " + i);
      parseZclUint(32, x, "Amount Collected " + i);
      parseZclEnum(8, x, "Debt Type " + i);
      parseZclUint(32, x, "Outstanding Debt " + i);
    }
  }

  // ZSE Calendar Cluster

  function parseZseGetDayProfiles(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUint(8, x, "Start Day Id");
    parseZclUint(8, x, "Number of Days");
  }

  function parseZseGetWeekProfiles(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUint(8, x, "Start Week Id");
    parseZclUint(8, x, "Number of Weeks");
  }

  function parseZseGetSeasons(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUint(32, x, "Issuer Calendar Id");
  }

  function parseZseGetSpecialDays(x) {
    parseZclUtcTime(x, "Start Time");
    parseZclUint(8, x, "Number of Events");
    parseZclCalendarUint(8, x, "Calendar Type");
    parseZclUint(32, x, "Provider Id");
    parseZclUint(32, x, "Issuer Calendar Id");
  }

  function parseZsePublishCalendar(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUtcTime(x, "Start Time");
    parseZclCalendarUint(8, x, "Calendar Type");
    parseZclUint(8, x, "Calendar Time Reference");
    parseZclOctetString(x, "Calendar Name");
    parseZclUint(8, x, "Number of Seasons");
    parseZclUint(8, x, "Number of Week Profiles");
    parseZclUint(8, x, "Number of Day Profiles");
  }

  function parseZsePublishDayProfile(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUint(8, x, "Day Id");
    var entries = parseZclUint(8, x, "Number of Schedule Entries");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    var calendarType = parseZclCalendarUint(8, x, "Calendar Type");
    for (var i = 1; i <= entries; i++) {
      var dec = parseNumberLE(x, 2);
      var hour = Math.floor(dec / 60);
      if (hour < 10)
        hour = "0" + hour;
      var minute = Math.floor(dec % 60);
      if (minute < 10)
        minute = "0" + minute;
      var time = "" + hour + ":" + minute;
      putBytes("Schedule Entry " + i + " Start Time", getBytes(x, 2), time);
      if (calendarType == 0x00)
        parseZclUint(8, x, "Price Tier " + i);
      else
        parseZclUint(8, x, "Friendly Credit Enable " + i);
    }
  }

  function parseZsePublishWeekProfile(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUint(8, x, "Week Id");
    putBytes("Day Id Refs (Monday to Sunday)", getBytes(x, 7));
  }

  function parseZsePublishSeasons(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    for (var i = 1; x.index < x.end; i++) {
      parseZclDate(x, "Season " + i + " Start Date");
      parseZclUint(8, x, "Season " + i + " Week Id Ref");
    }
  }

  function parseZsePublishSpecialDays(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUint(32, x, "Issuer Calendar Id");
    parseZclUtcTime(x, "Start Time");
    parseZclCalendarUint(8, x, "Calendar Type");
    var numberOfSpecialDays = parseZclUint(8, x, "Number of Special Days");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Number of Commands");
    for (var i = 1; i <= numberOfSpecialDays; i++) {
      parseZclDate(x, "Special Day " + i + " Date");
      parseZclUint(8, x, "Special Day " + i + " Day Id Ref");
    }
  }

  // ZSE Device Management Cluster

  function parseZseReportEventConfiguration(x) {
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Total Commands");
    for (var i = 1; x.index < x.end; i++) {
      parseZclUint(16, x, "Event Id " + i);
      parseZclBitmap(8, x, "Event Configuration " + i);
    }
  }

  function parseZsePublishChangeOfTenancy(x) {
    parseZclUint(32, x, "Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclBitmap(8, x, "Tariff Type");
    parseZclUtcTime(x, "Implmentation Date Time");
    parseZclBitmap(32, x, "Proposed Tenancy Change Control");
  }

  function parseZsePublishChangeOfSupplier(x) {
    parseZclUint(32, x, "Current Provider Id");
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclBitmap(8, x, "Tariff Type");
    parseZclUint(32, x, "Proposed Provider Id");
    parseZclUtcTime(x, "Provider Change Implementation Time");
    parseZclBitmap(32, x, "Provider Change Control");
    parseZclOctetString(x, "Proposed Provider Name");
    parseZclOctetString(x, "Proposed Provider Contact Details");
  }

  function parseZseRequestNewPasswordResponse(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Implmentation Date Time");
    parseZclUint(16, x, "Duration in Minutes");
    parseZclEnum(8, x, "Password Type");
    parseZclOctetString(x, "Password");
  }

  function parseZseUpdateSiteId(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Site Id Time");
    parseZclUint(32, x, "Provider Id");
    parseZclOctetString(x, "Site Id");
  }

  function parseZseSetEventConfiguration(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "Start Date Time");
    parseZclBitmap(8, x, "Event Configuration");
    parseZclEnum(8, x, "Configuration Control");
    // Event Configuration Payload (Apply by List)
    var n = parseZclUint(8, x, "Number of Events");
    for (var i = 1; i <= n; i++) {
      parseZclUint(16, x, "Event Id");
    }
  }

  function parseZseGetEventConfiguration(x) {
    parseZclUint(16, x, "Event Id");
  }

  function parseZseUpdateCin(x) {
    parseZclUtcTime(x, "Issuer Event Id");
    parseZclUtcTime(x, "CIN Implementation Time");
    parseZclUint(32, x, "Provider Id");
    parseZclOctetString(x, "Customer Id Number");
  }

  // ZSE Event Cluster

  function parseZseGetEventLog(x) {
    parseZclBitmap(8, x, "Event Control / Log Id");
    parseZclUint(16, x, "Event Id");
    parseZclUtcTime(x, "Start Time");
    parseZclUtcTime(x, "End Time");
    parseZclUint(8, x, "Number of Events");
    parseZclUint(16, x, "Event Offset");
  }

  function parseZseClearEventLogRequest(x) {
    parseZclBitmap(8, x, "Log Id");
  }

  function parseZsePublishEventLog(x) {
    parseZclUint(16, x, "Number of Events");
    parseZclUint(8, x, "Command Index");
    parseZclUint(8, x, "Total Commands");
    parseZclBitmap(8, x, "Log Payload Control");
    for (var i = 1; x.index < x.end; i++) {
      parseLogIdBitmap(8, x, "Log Id " + i);
      parseZclUintHex(16, x, "Event Id " + i);
      parseZclUtcTime(x, "Event Time " + i);
      parseZclOctetString(x, "Event Data " + i);
    }
  }

  function parseZseClearEventLogResponse(x) {
    parseZclBitmap(8, x, "Cleared Event Logs");
  }

  // ZCL Types

  function parseZclUint(bits, x, name, values) {
    var value = 0;
    var bytes = bits / 8;
    value = parseNumberLE(x, bytes);
    putBytes(name, getBytes(x, bytes), tooltip(values && (values[value] || "Unknown") || value, toHex(value, bits)));
    return value;
  }

  function parseZclUintHex(bits, x, name) {
    var value = 0;
    var bytes = bits / 8;
    value = parseNumberLE(x, bytes);
    putBytes(name, getBytes(x, bytes), "0x" + value.toString(16));
    return value;
  }

  function getCalendarTypeName(/*int*/ calendarType) {
    var names = {
      0x00: "Delivered Calendar",
      0x01: "Received Calendar",
      0x02: "Delivered and Received Calendar",
      0x03: "Friendly Credit Calendar",
      0x04: "Auxiliary Load Switch Calendar",
    };
    if (calendarType <= 0x04)
        return names[calendarType];
    else
        return "Reserved"
  }

  function parseZclCalendarUint(bits, x, name) {
    var bytes = bits / 8; //useless
    var calendarType = x.input[x.index];
    putBytes(name, getBytes(x, bytes), getCalendarTypeName(calendarType));
    return calendarType;
  }

  function parseZclInt32(x, name) {
    var value = parseNumberLE(x, 4);
    if (value > 0x7fffffff)
      value -= 0x100000000;
    putBytes(name, getBytes(x, 4), value);
    return value;
  }

  function parseZclOctetString(x, name) {
    var length = x.input[x.index];
    var value = "";
    for (var i = 0; i < length; i++) {
      value += String.fromCharCode(x.input[x.index + 1 + i]);
    }
    var printableValue = value.replace(/[^\x20-\x7E]/g, " ");
    putBytes(name, getBytes(x, 1 + length), printableValue);
  }

  function parseZclBitmap(bits, x, name, values) {
    var number = parseNumberLE(x, bits / 8);
    var value = toHex(number, bits);
    if (bits <= 16) {
      function prettybit(index, bit) {
        return tooltip(bit, "Bit #" + index);
      }
      value += " = 0b";
      // Be careful, it's Little Endian
      for (var i = 0; i < bits / 8; i++) {
        // full byte
        var b = x.input[x.index + bits / 8 - 1 - i];
        for (var j = 0; j < 8; j++) {
          value += prettybit(i * 8 + j, (b >> (7 - j)) & 1);
        }
      }
    }
    putBytes(name, getBytes(x, bits / 8), values && (values[number] || "Unknown") || value);
  }

  function getLogIdType(/*int*/ logIdType) {
    var names = {
      0x00: "All logs",
      0x01: "Tamper Log",
      0x02: "Fault Log",
      0x03: "General Event Log",
      0x04: "Security Event Log",
      0x05: "Network Event Log",
    };
    if (logIdType <= 0x05)
        return names[logIdType];
    else
        return "Reserved"
  }

  function parseLogIdBitmap(bits, x, name) {
    var logIdType = x.input[x.index]
    putBytes(name, getBytes(x, bits / 8), getLogIdType(logIdType));
  }

  function parseZclEnum(bits, x, name, values) {
    parseZclUint(bits, x, name, values);
  }

  function parseZclDate(x, name) {
    var year = x.input[x.index];
    var month = x.input[x.index + 1];
    var dayOfMonth = x.input[x.index + 2];
    var dayOfWeek = x.input[x.index + 3];

    //Day
    if (dayOfMonth == 255)
      var hday = "every day";
    else if (dayOfMonth == 0xFD)
      var hday = "2nd last " + daysInWeek[dayOfWeek] + " of"
    else if (dayOfMonth == 0xFE)
      var hday = "last " + daysInWeek[dayOfWeek] + " of"
    else if (dayOfMonth < 10)
      var hday = "0" + dayOfMonth;
    else
      var hday = dayOfMonth;

    //Month
    if (month == 255)
      var hmon = "every month of";
    else if (month == 0xFD)
      var hmon = "DST-end month of";
    else if (month == 0xFE)
      var hmon = "DST-begin month of";
    else
      var hmon = monthsInYear[month];

    //Year
    if (year == 255)
      var hyear = "every year";
    else
      var hyear = 1900 + year;

    var date = hday + " " + hmon + " " + hyear;
    putBytes(name, getBytes(x, 4), date);
  }

  function parseGbzTime(x, name) {
    var value = parseNumber(x, 4);
    putBytes(name, getBytes(x, 4), toUtcTimeString(value));
  }

  function parseZclUtcTime(x, name) {
    var value = parseNumberLE(x, 4);
    putBytes(name, getBytes(x, 4), toUtcTimeString(value));
  }

  function toUtcTimeString(value) {
    var text = "";
    if (value != 0 && value != 0xffffffff) {
      var secondsSince2000 = value;
      var secondsSince1970 = secondsSince2000 + 946684800;
      var millisecondsSince1970 = secondsSince1970 * 1000;
      var d = new Date(millisecondsSince1970);
      text = d.getUTCFullYear() + "-";
      var month = d.getUTCMonth() + 1;
      if (month < 10)
        text += "0";
      text += month + "-";
      var day = d.getUTCDate();
      if (day < 10)
        text += "0";
      text += day + " ";
      var hour = d.getUTCHours();
      if (hour < 10)
        text += "0";
      text += hour + ":";
      var minute = d.getUTCMinutes();
      if (minute < 10)
        text += "0";
      text += minute + ":";
      var second = d.getUTCSeconds();
      if (second < 10)
        text += "0";
      text += second;
    }
    return text;
  }

  function parseZclUtrn(x, name) {
    var utrn = "";
    for (var i = 0; i < 20; i++)
      utrn += String.fromCharCode(x.input[x.index + 1 + i]);
    var pptd = [ 0, 0 ];  /* two 32-bit numbers [ least significat, most significant ] */
    for (var i = 0; i < 19; i++) {
      var digit = utrn.charCodeAt(i) - 0x30;
      var pptd0 = pptd[0] * 10 + digit;
      pptd[0] = Math.floor(pptd0 % 0x100000000);
      var carry = Math.floor(pptd0 / 0x100000000);
      pptd[1] = pptd[1] * 10 + carry;  /* 304E2FF674C64 */
    }
    var pptdSubtrahend = [ 0x714A0000, 0x669D529B ];  /* 7,394,156,990,786,306,048 */
    var ptut = [];
    if (pptd[0] > pptdSubtrahend[0]) {
      ptut[0] = pptd[0] - pptdSubtrahend[0];
      ptut[1] = pptd[1] - pptdSubtrahend[1];
    } else {
      ptut[0] = pptd[0] - pptdSubtrahend[0] + 0x100000000;
      ptut[1] = pptd[1] - pptdSubtrahend[1] - 1;
    }
    var ptutValue = ptut[1] & 0x1fff;
    var ptutValueClass = (ptut[1] >> 13) & 3;
    putBytes(name, getBytes(x, 21), "UTRN: " + utrn + ", PTUT Value Class: " + ptutValueClass + ", PTUT Value: " + ptutValue);
  }

  function parseZclStatusCode(x) {
    var names = {
      0x00: "Success",
      0x01: "Failure",
      0x7e: "Not Authorized",
      0x7f: "Reserved Field Not Zero",
      0x80: "Malformed Command",
      0x81: "Unsup Cluster Command",
      0x82: "Unsup General Command",
      0x83: "Unsup Manuf Cluster Command",
      0x84: "Unsup Manuf General Command",
      0x85: "Invalid Field",
      0x86: "Unsupported Attribute",
      0x87: "Invalid Value",
      0x88: "Read Only",
      0x89: "Insufficient Space",
      0x8a: "Duplicate Exists",
      0x8b: "Not Found",
      0x8c: "Unreportable Attribute",
      0x8d: "Invalid Data Type",
      0x8e: "Invalid Selector",
      0x8f: "Write Only",
      0x90: "Inconsistent Startup State",
      0x91: "Defined Out Of Band",
      0x92: "Inconsistent",
      0x93: "Action Denied",
      0x94: "Timeout",
      0x95: "Abort",
      0x96: "Invalid Image",
      0x97: "Wait For Data",
      0x98: "No Image Available",
      0x99: "Require More Image",
      0xc0: "Hardware Failure",
      0xc1: "Software Failure",
      0xc2: "Calibration Error",
    };
    var value = x.input[x.index];
    var name = names[value] || "";
    putBytes("Status Code", getBytes(x, 1), name);
    return value;
  }
}

function loadFromHash() {
    if (window.location.hash && window.location.hash != hash) {
        hash = window.location.hash;
        // Firefox is not consistent with other browsers and return an
        // already-decoded hash string so we risk double-decoding here,
        // but since % is not allowed in base64 nor hexadecimal, it's ok
        var val = decodeURIComponent(hash.substr(1));
        textarea.value = val;
        parse();
    }
}

function stop(e) {
    e.stopPropagation();
    e.preventDefault();
}

// main
textarea = document.getElementById("textarea");
hash = null;

textarea.onkeydown = function(e) {
  if ((event.keyCode == 10 || event.keyCode == 13) && event.ctrlKey) {
    parse();
  }
}

if ('onhashchange' in window)
    window.onhashchange = loadFromHash;
loadFromHash();
document.ondragover = stop;
document.ondragleave = stop;
</script>
</body>
</html>
